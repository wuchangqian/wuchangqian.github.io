<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | 每个人的声音都面向世界]]></title>
  <link href="http://me.94313.net/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://me.94313.net/"/>
  <updated>2017-09-06T18:12:13+08:00</updated>
  <id>http://me.94313.net/</id>
  <author>
    <name><![CDATA[wuchangqian]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Shell History 命令扩展]]></title>
    <link href="http://me.94313.net/blog/2017/08/10/shell-history/"/>
    <updated>2017-08-10T11:35:36+08:00</updated>
    <id>http://me.94313.net/blog/2017/08/10/shell-history</id>
    <content type="html"><![CDATA[<p><img src="/images/shell_history.png" title="shell history 命令扩展" alt="shell history 命令扩展" /></p>

<ol>
<li>!^ 获取上一条命令的第一个参数。</li>
<li>!$ 获取上一条命令的最后一个参数。</li>
<li>!:n 获取上一条命令的第n个参数，n从1开始。（为0时则挑选出命令名称）</li>
<li>!:n-x 获取上一条命令的第n个参数到第x个参数，n和x均从1开始。（为0时则挑选出命令名称）</li>
<li>!* 获取上一条命令的所有参数。</li>
<li>!n* n为数字，获取上一条命令的从第n个参数（含第n个参数）后的所有参数。</li>
<li>!n- n为数字，获取上一条命令的从第n个参数（含第n个参数）后的除了最后一个参数外的所有参数。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows 下ffmpeg使用]]></title>
    <link href="http://me.94313.net/blog/2017/05/07/windows-xia-ffmpegshi-yong/"/>
    <updated>2017-05-07T18:14:09+08:00</updated>
    <id>http://me.94313.net/blog/2017/05/07/windows-xia-ffmpegshi-yong</id>
    <content type="html"><![CDATA[<p>列出设备</p>

<pre><code>1. ffmpeg -list_devices true -f dshow -i dummy  
</code></pre>

<p>保存文件</p>

<pre><code>1. ffmpeg -f dshow -i video="Integrated Camera" -vcodec libx264 mycamera.mkv  
</code></pre>

<p>直接播放</p>

<pre><code>1. ffplay -f dshow -i video="Integrated Camera"  
</code></pre>

<p>推流</p>

<pre><code>1. ffmpeg -f dshow -i video="Integrated Camera" -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f flv rtmp://192.168.1.5/mytv/test1
</code></pre>

<p>录制屏幕</p>

<pre><code>1. ffmpeg -f -dshow -s 1600x900 -r 50 -vcodec libx264 –preset:v ultrafast –tune:v zerolatency -crf 18 -f mpegts rtmp://192.168.1.5/mytv/test2      在Windows平台下，使用-dshow取代x11grab
</code></pre>

<p>-i 指定输入的文件
-acodec 指定输出文件的音频编码
-vcodec 指定输出文件的视频编码</p>

<p>最简单的抓屏：</p>

<pre><code>ffmpeg -f gdigrab -i desktop out.mpg
</code></pre>

<p>从屏幕的（10,20）点处开始，抓取640x480的屏幕，设定帧率为5</p>

<pre><code>ffmpeg -f gdigrab -framerate 5 -offset_x 10 -offset_y 20 -video_size 640x480 -i desktop out.mpg
</code></pre>

<p>//=======================================================================
    ffmpeg -ss START -t DURATION -i INPUT -vcodec copy -acodec copy OUTPUT
    对上面的命令稍做个解释。
    -ss 开始时间，如： 00:00:20，表示从20秒开始；
    -t 时长，如： 00:00:10，表示截取10秒长的视频；
    -i 输入，后面是空格，紧跟着就是输入视频文件；
    -vcodec copy 和 -acodec copy表示所要使用的视频和音频的编码格式，这里指定为copy表示原样拷贝；
    INPUT，输入视频文件；
    OUTPUT，输出视频文件；
//=======================================================================</p>

<pre><code>ffmpeg -f x11grab -s xga -r 10 -i :0.0+0+0 wheer.avi
-i video="screen-capture-recorder"

ffmpeg -f dshow -i video="DirectShow video devices" -f dshow -i audio="DirectShow audio devices" -pix_fmt yuv420p -vcodec libx264 -acodec libvo_aacenc -s 1280x720 -r 25 -q 10 -ar 44100 -ac 2 -tune zerolatency -preset ultrafast -f mpegts - | ffmpeg -f mpegts -i - -c copy -bsf:a aac_adtstoasc -f flv temp.flv
</code></pre>

<p>-r选项设置每秒提取图片的帧数。
-q:v 2  设置输出文件的视频质量为：优</p>

<p>截取一张352x240尺寸大小的，格式为jpg的图片</p>

<pre><code>ffmpeg -i 1.mp4 -y -f image2 -t 120.001 -s 352x240 a.jpg
</code></pre>

<p>把视频的前30帧转换成一个Animated Gif ：</p>

<pre><code>ffmpeg -i 1.mp4 -vframes 30 -y -f gif a.gif
</code></pre>

<p>生成缩略图</p>

<pre><code>ffmpeg -i 1.mp4 -y -f image2 -ss 08.010 -t 0.001 -s 352x240 b.jpg
</code></pre>

<p>列出本机设备</p>

<pre><code>ffmpeg -list_devices true -f dshow -i dummy
</code></pre>

<p>从视频中生成gif图片</p>

<pre><code>ffmpeg -i 1.mp4 -ss 10 -t 10   -s 480x360  tutu.gif
</code></pre>

<h2>-ss 指从 10s 开始转码,-t 指转换 10s 的视频 -s 指定尺寸</h2>

<pre><code>rtmp://video-center.alivecdn.com/AppName/StreamName?vhost=zhibo.busionline.com
</code></pre>

<p>前言：FFmpeg是做音视频开发的一个优秀的开源库，可以在不同平台下编译，能够实现视频采集、视频格式转化、视频截图、视频添加水印、视频切片、视频录制、视频推流、更改音视频参数功能等。通过终端命令及开发时如何实现这些功能，本文做一整理记录，以备不时之需。下面共四组命令。</p>

<p>第一组</p>

<p>1.分离视频音频流</p>

<pre><code>ffmpeg -i input_file -vcodec copy -an output_file_video　　//分离视频流ffmpeg -i input_file -acodec copy -vn output_file_audio　　//分离音频流
</code></pre>

<p>2.视频解复用</p>

<pre><code>ffmpeg –i test.mp4 –vcodec copy –an –f m4v test.264

ffmpeg –i test.avi –vcodec copy –an –f m4v test.264
</code></pre>

<p>3.视频转码</p>

<pre><code>ffmpeg –i test.mp4 –vcodec h264 –s 352*278 –an –f m4v test.264
</code></pre>

<p>//转码为码流原始文件</p>

<pre><code>ffmpeg –i test.mp4 –vcodec h264 –bf 0 –g 25 –s 352*278 –an –f m4v test.264 //转码为码流原始文件

ffmpeg –i test.avi -vcodec mpeg4 –vtag xvid –qsame test_xvid.avi //转码为封装文件
</code></pre>

<p>说明：-bf B帧数目控制，-g 关键帧间隔控制，-s 分辨率控制</p>

<p>4.视频封装</p>

<pre><code>ffmpeg –i video_file –i audio_file –vcodec copy –acodec copy output_file
</code></pre>

<p>5.视频剪切</p>

<pre><code>ffmpeg –i test.avi –r 1 –f image2 image-%3d.jpeg //提取图片

ffmpeg -ss 0:1:30 -t 0:0:20 -i input.avi -vcodec copy -acodec copy output.avi //剪切视频//-r 提取图像的频率，-ss 开始时间，-t 持续时间
</code></pre>

<p>6.视频录制</p>

<pre><code>ffmpeg –i rtsp://192.168.3.205:5555/test –vcodec copy out.avi
</code></pre>

<p>7、利用ffmpeg视频切片</p>

<p>主要把视频源切成若干个.ts格式的视频片段然后生成一个.m3u8的切片文件索引提供给html5的video做hls直播源</p>

<p>命令如下：</p>

<pre><code>ffmpeg -i 视频源地址 -strict -2 -c:v libx264 -c:a aac -f hls m3u8文件输出地址
</code></pre>

<p>8、ffmpeg缩放视频</p>

<p>假设原始视频尺寸是 1080p（即 1920×1080 px，16:9），使用下面命令可以缩小到 480p：(ps:以下这个命令，据说违反微信平台相关法律，蛋疼，用不了文字，只能用图片了)</p>

<p>各个参数的含义：-i a.mov 指定待处理视频的文件名-vf scale=853:480 vf 参数用于指定视频滤镜，其中 scale 表示缩放，后面的数字表示缩放至 853×480 px，其中的 853px 是计算而得，因为原始视频的宽高比为 16:9，所以为了让目标视频的高度为 480px，则宽度 = 480 x 9 / 16 = 853-acodec aac 指定音频使用 aac 编码。注：因为 ffmpeg 的内置 aac 编码目前还是试验阶段，故会提示添加参数 “-strict -2” 才能继续，尽管添加即可。又或者使用外部的 libfaac（需要重新编译 ffmpeg）。-vcodec h264 指定视频使用 h264 编码。注：目前手机一般视频拍摄的格式（封装格式、文件格式）为 mov 或者 mp4，这两者的音频编码都是 aac，视频都是 h264。out.mp4 指定输出文件名上面的参数 scale=853:480 当中的宽度和高度实际应用场景中通常只需指定一个，比如指定高度为 480 或者 720，至于宽度则可以传入 “-1” 表示由原始视频的宽高比自动计算而得。即参数可以写为：scale=-1:480，当然也可以 scale=480:-1</p>

<p>9、ffmpeg裁剪</p>

<p>有时可能只需要视频的正中一块，而两头的内容不需要，这时可以对视频进行裁剪（crop），比如有一个竖向的视频 1080 x 1920，如果指向保留中间 1080×1080 部分命令如下：ffmpeg -i 视频源地址 -strict -2 -vf crop=1080:1080:0:420 视频输出地址（如：out.mp4）</p>

<p>其中的 crop=1080:1080:0:420 才裁剪参数，具体含义是 crop=width:height:x:y，其中 width 和 height 表示裁剪后的尺寸，x:y 表示裁剪区域的左上角坐标。比如当前这个示例，我们只需要保留竖向视频的中间部分，所以 x 不用偏移，故传入0，而 y 则需要向下偏移：(1920 – 1080) / 2 = 420</p>

<ol>
<li><p>转视频格式</p>

<p>ffmpeng -i source.mp4 -c:v libx264 -crf 24 destination.flv</p></li>
</ol>


<p>其中 -crf 很重要，是控制转码后视频的质量，质量越高，文件也就越大。</p>

<p>此值的范围是 0 到 51：0 表示高清无损；23 是默认值（如果没有指定此参数）；51 虽然文件最小，但效果是最差的。</p>

<p>值越小，质量越高，但文件也越大，建议的值范围是 18 到 28。而值 18 是视觉上看起来无损或接近无损的，当然不代表是数据（技术上）的转码无损。</p>

<p>第二组</p>

<p>1.ffmpeg 把文件当做直播推送至服务器 (RTMP + FLV)</p>

<pre><code>ffmpeg - re -i demo.mp4 -c copy - f flv rtmp://w.gslb.letv/live/streamid
</code></pre>

<p>2.将直播的媒体保存到本地</p>

<pre><code>ffmpeg -i rtmp://r.glsb.letv/live/streamid -c copy streamfile.flv
</code></pre>

<p>3.将一个直播流，视频改用h264压缩，音频改用faac压缩，送至另一个直播服务器</p>

<pre><code>ffmpeg -i rtmp://r.glsb.letv/live/streamidA -c:a libfaac -ar 44100 -ab 48k -c:v libx264 -vpre slow -vpre baseline -f flv rtmp://w.glsb.letv/live/streamb
</code></pre>

<p>4.提取视频中的音频,并保存为mp3 然后输出</p>

<pre><code>ffmpeg -i input.avi -b:a 128k output.mp3
</code></pre>

<ol>
<li><p>将mp3转为pcm</p>

<p> ffmpeg-iinput.mp3-fs16be-acodecpcm_s16beoutput.pcm</p></li>
</ol>


<p>第三组</p>

<p>1.获取视频的信息</p>

<pre><code>ffmpeg -i video.avi
</code></pre>

<p>2.将图片序列合成视频</p>

<pre><code>ffmpeg -f image2 -i image%d.jpg video.mpg
</code></pre>

<p>上面的命令会把当前目录下的图片（名字如：image1.jpg. image2.jpg. 等&hellip;）合并成video.mpg</p>

<p>3.将视频分解成图片序列</p>

<pre><code>ffmpeg -i video.mpg image%d.jpg
</code></pre>

<p>上面的命令会生成image1.jpg. image2.jpg. &hellip;</p>

<pre><code>支持的图片格式有：PGM. PPM. PAM. PGMYUV. JPEG. GIF. PNG. TIFF. SGI
</code></pre>

<p>4.为视频重新编码以适合在iPod/iPhone上播放</p>

<pre><code>ffmpeg -i source_video.avi input -acodec aac -ab 128kb -vcodec mpeg4 -b 1200kb -mbd 2 -flags +4mv+trell -aic 2 -cmp 2 -subcmp 2 -s 320x180 -title X final_video.mp4
</code></pre>

<p>5.为视频重新编码以适合在PSP上播放</p>

<pre><code>ffmpeg -i source_video.avi -b 300 -s 320x240 -vcodec xvid -ab 32 -ar 24000 -acodec aac final_video.mp4
</code></pre>

<p>6.从视频抽出声音.并存为Mp3</p>

<pre><code>ffmpeg -i source_video.avi -vn -ar 44100 -ac 2 -ab 192 -f mp3 sound.mp3
</code></pre>

<p>7.将wav文件转成Mp3</p>

<pre><code>ffmpeg -i son_origine.avi -vn -ar 44100 -ac 2 -ab 192 -f mp3 son_final.mp3
</code></pre>

<p>8.将.avi视频转成.mpg</p>

<pre><code>ffmpeg -i video_origine.avi video_finale.mpg
</code></pre>

<p>9.将.mpg转成.avi</p>

<pre><code>ffmpeg -i video_origine.mpg video_finale.avi
</code></pre>

<p>10.将.avi转成gif动画（未压缩）</p>

<pre><code>ffmpeg -i video_origine.avi gif_anime.gif
</code></pre>

<p>11.合成视频和音频</p>

<pre><code>ffmpeg -i son.wav -i video_origine.avi video_finale.mpg
</code></pre>

<p>12.将.avi转成.flv</p>

<pre><code>ffmpeg -i video_origine.avi -ab 56 -ar 44100 -b 200 -r 15 -s 320x240 -f flv video_finale.flv
</code></pre>

<p>13.将.avi转成dv</p>

<pre><code>ffmpeg -i video_origine.avi -s pal -r pal -aspect 4:3 -ar 48000 -ac 2 video_finale.dv
</code></pre>

<p>或者：</p>

<pre><code>ffmpeg -i video_origine.avi -target pal-dv video_finale.dv
</code></pre>

<p>14.将.avi压缩成divx</p>

<pre><code>ffmpeg -i video_origine.avi -s 320x240 -vcodec msmpeg4v2 video_finale.avi
</code></pre>

<p>15.将Ogg Theora压缩成Mpeg dvd</p>

<pre><code>ffmpeg -i film_sortie_cinelerra.ogm -s 720x576 -vcodec mpeg2video -acodec mp3 film_terminate.mpg
</code></pre>

<p>16.将.avi压缩成SVCD mpeg2</p>

<p>NTSC格式：</p>

<pre><code>ffmpeg -i video_origine.avi -target ntsc-svcd video_finale.mpg
</code></pre>

<p>PAL格式：</p>

<pre><code>ffmpeg -i video_origine.avi -target pal-dvcd video_finale.mpg
</code></pre>

<p>17.将.avi压缩成VCD mpeg2</p>

<pre><code>NTSC格式： 
ffmpeg -i video_origine.avi -target ntsc-vcd video_finale.mpg
</code></pre>

<p>PAL格式：</p>

<pre><code>ffmpeg -i video_origine.avi -target pal-vcd video_finale.mpg
</code></pre>

<p>18.多通道编码</p>

<pre><code>ffmpeg -i fichierentree -pass 2 -passlogfile ffmpeg2pass fichiersortie-2
</code></pre>

<p>19.从flv提取mp3</p>

<pre><code>ffmpeg -i source.flv -ab 128k dest.mp3
</code></pre>

<p>第四组</p>

<p>1、将文件当做直播送至live</p>

<pre><code>ffmpeg -re -i localFile.mp4 -c copy -f flv rtmp://server/live/streamName
</code></pre>

<p>2、将直播媒体保存至本地文件</p>

<pre><code>ffmpeg -i rtmp://server/live/streamName -c copy dump.flv
</code></pre>

<p>3、将其中一个直播流，视频改用h264压缩，音频不变，送至另外一个直播服务流</p>

<pre><code>ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v libx264 -vpre slow -f flv rtmp://server/live/h264Stream
</code></pre>

<p>4、将其中一个直播流，视频改用h264压缩，音频改用faac压缩，送至另外一个直播服务流</p>

<pre><code>ffmpeg -i rtmp://server/live/originalStream -c:a libfaac -ar 44100 -ab 48k -c:v libx264 -vpre slow -vpre baseline -f flv rtmp://server/live/h264Stream
</code></pre>

<p>5、将其中一个直播流，视频不变，音频改用faac压缩，送至另外一个直播服务流</p>

<pre><code>ffmpeg -i rtmp://server/live/originalStream -acodec libfaac -ar 44100 -ab 48k -vcodec copy -f flv rtmp://server/live/h264_AAC_Stream
</code></pre>

<p>6、将一个高清流，复制为几个不同视频清晰度的流重新发布，其中音频不变</p>

<pre><code>ffmpeg -re -i rtmp://server/live/high_FMLE_stream -acodec copy -vcodec x264lib -s 640×360 -b 500k -vpre medium -vpre baseline rtmp://server/live/baseline_500k -acodec copy -vcodec x264lib -s 480×272 -b 300k -vpre medium -vpre baseline rtmp://server/live/baseline_300k -acodec copy -vcodec x264lib -s 320×200 -b 150k -vpre medium -vpre baseline rtmp://server/live/baseline_150k -acodec libfaac -vn -ab 48k rtmp://server/live/audio_only_AAC_48k
</code></pre>

<p>7、功能一样，只是采用-x264opts选项</p>

<pre><code>ffmpeg -re -i rtmp://server/live/high_FMLE_stream -c:a copy -c:v x264lib -s 640×360 -x264opts bitrate=500:profile=baseline:preset=slow rtmp://server/live/baseline_500k -c:a copy -c:v x264lib -s 480×272 -x264opts bitrate=300:profile=baseline:preset=slow rtmp://server/live/baseline_300k -c:a copy -c:v x264lib -s 320×200 -x264opts bitrate=150:profile=baseline:preset=slow rtmp://server/live/baseline_150k -c:a libfaac -vn -b:a 48k rtmp://server/live/audio_only_AAC_48k
</code></pre>

<p>8、将当前摄像头及音频通过DSSHOW采集，视频h264、音频faac压缩后发布</p>

<pre><code>ffmpeg -r 25 -f dshow -s 640×480 -i video=”video source name”:audio=”audio source name” -vcodec libx264 -b 600k -vpre slow -acodec libfaac -ab 128k -f flv rtmp://server/application/stream_name
</code></pre>

<p>9、将一个JPG图片经过h264压缩循环输出为mp4视频</p>

<pre><code>ffmpeg.exe -i INPUT.jpg -an -vcodec libx264 -coder 1 -flags +loop -cmp +chroma -subq 10 -qcomp 0.6 -qmin 10 -qmax 51 -qdiff 4 -flags2 +dct8x8 -trellis 2 -partitions +parti8x8+parti4x4 -crf 24 -threads 0 -r 25 -g 25 -y OUTPUT.mp4
</code></pre>

<p>10、将普通流视频改用h264压缩，音频不变，送至高清流服务(新版本FMS live=1)</p>

<pre><code>ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v libx264 -vpre slow -f flv “rtmp://server/live/h264Stream live=1〃
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Htop是个好东西]]></title>
    <link href="http://me.94313.net/blog/2015/01/06/htop/"/>
    <updated>2015-01-06T13:49:16+08:00</updated>
    <id>http://me.94313.net/blog/2015/01/06/htop</id>
    <content type="html"><![CDATA[<pre><code>Htop是一款运行于Linux系统监控与进程管理软件，用于取代Unix下传统的top。与top只提供最消耗资源的进程列表不同，htop提供所有进程的列表，并且使用彩色标识出处理器、swap和内存状态。
</code></pre>

<p>用户一般可以在top无法提供详尽系统信息的情况下选择安装并使用htop。比如，在查找应用程序的内存泄漏问题时。与top相比，htop提供更方便、光标控制的界面来杀死进程。
htop用C语言编写，采用了ncurses库。htop的名称源于其作者的名字。</p>

<h2>安装-htop</h2>

<pre><code>yum -y install ncurses-devel #htop依赖ncurses
cd /opt
wget -c http://ncu.dl.sourceforge.net/project/htop/htop/1.0.2/htop-1.0.2.tar.gz
tar xzf htop-1.0.2.tar.gz
cd htop-1.0.2
./configure
make &amp;&amp; make install
</code></pre>

<h2>示例图片</h2>

<p><img src="/images/2015/htop.gif" title="示例图片" alt="示例图片" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sed-man-page]]></title>
    <link href="http://me.94313.net/blog/2014/09/01/sed-man-page/"/>
    <updated>2014-09-01T18:30:03+08:00</updated>
    <id>http://me.94313.net/blog/2014/09/01/sed-man-page</id>
    <content type="html"><![CDATA[<p>NAME
       sed - stream editor for filtering and transforming text</p>

<p>SYNOPSIS
       sed [OPTION]&hellip; {script-only-if-no-other-script} [input-file]&hellip;</p>

<p>DESCRIPTION
       Sed  is  a stream editor.  A stream editor is used to perform basic text transformations on an input stream (a file
       or input from a pipeline).  While in some ways similar to an editor which permits scripted edits (such as ed),  sed
       works  by  making  only one pass over the input(s), and is consequently more efficient.  But it is sed&rsquo;s ability to
       filter text in a pipeline which particularly distinguishes it from other types of editors.</p>

<pre><code>   -n, --quiet, --silent

          suppress automatic printing of pattern space

   -e script, --expression=script

          add the script to the commands to be executed

   -f script-file, --file=script-file

          add the contents of script-file to the commands to be executed

   --follow-symlinks

          follow symlinks when processing in place

   -i[SUFFIX], --in-place[=SUFFIX]

          edit files in place (makes backup if SUFFIX supplied)

   -b, --binary

          open files in binary mode (CR+LFs are not processed specially)

   -l N, --line-length=N

          specify the desired line-wrap length for the `l' command

   --posix

          disable all GNU extensions.

   -r, --regexp-extended

          use extended regular expressions in the script.

   -s, --separate

          consider files as separate rather than as a single continuous long stream.

   -u, --unbuffered

          load minimal amounts of data from the input files and flush the output buffers more often

   -z, --null-data

          separate lines by NUL characters

   --help
          display this help and exit

   --version
          output version information and exit

   If no -e, --expression, -f, or --file option is given, then the first non-option  argument  is  taken  as  the  sed
   script  to  interpret.  All remaining arguments are names of input files; if no input files are specified, then the
   standard input is read.

   GNU sed home page: &lt;http://www.gnu.org/software/sed/&gt;.  General help using GNU software:  &lt;http://www.gnu.org/geth‐
   elp/&gt;.   E-mail  bug  reports  to:  &lt;bug-sed@gnu.org&gt;.  Be sure to include the word ``sed'' somewhere in the ``Sub‐
   ject:'' field.
</code></pre>

<p>COMMAND SYNOPSIS
       This is just a brief synopsis of sed commands to serve as a reminder to those who already know sed; other  documen‐
       tation (such as the texinfo document) must be consulted for fuller descriptions.</p>

<p>   Zero-address &ldquo;commands&rdquo;
       : label
              Label for b and t commands.</p>

<pre><code>   #comment
          The comment extends until the next newline (or the end of a -e script fragment).

   }      The closing bracket of a { } block.
</code></pre>

<p>   Zero- or One- address commands
       =      Print the current line number.</p>

<pre><code>   a \

   text   Append text, which has each embedded newline preceded by a backslash.

   i \

   text   Insert text, which has each embedded newline preceded by a backslash.

   q [exit-code]
          Immediately quit the sed script without processing any more input, except that if auto-print is not disabled
          the current pattern space will be printed.  The exit code argument is a GNU extension.

   Q [exit-code]
          Immediately quit the sed script without processing any more input.  This is a GNU extension.

   r filename
          Append text read from filename.

   R filename
          Append a line read from filename.  Each invocation of the command reads a line from the file.  This is a GNU
          extension.
</code></pre>

<p>   Commands which accept address ranges
       {      Begin a block of commands (end with a }).</p>

<pre><code>   b label
          Branch to label; if label is omitted, branch to end of script.

   c \

   text   Replace the selected lines with text, which has each embedded newline preceded by a backslash.

   d      Delete pattern space.  Start next cycle.

   D      If  pattern  space contains no newline, start a normal new cycle as if the d command was issued.  Otherwise,
          delete text in the pattern space up to the first newline, and  restart  cycle  with  the  resultant  pattern
          space, without reading a new line of input.

   h H    Copy/append pattern space to hold space.

   g G    Copy/append hold space to pattern space.

   l      List out the current line in a ``visually unambiguous'' form.

   l width
          List  out  the  current line in a ``visually unambiguous'' form, breaking it at width characters.  This is a
          GNU extension.

   n N    Read/append the next line of input into the pattern space.

   p      Print the current pattern space.

   P      Print up to the first embedded newline of the current pattern space.

   s/regexp/replacement/
          Attempt to match regexp against the pattern  space.   If  successful,  replace  that  portion  matched  with
          replacement.   The  replacement  may contain the special character &amp; to refer to that portion of the pattern
          space which matched, and the special escapes \1 through \9 to  refer  to  the  corresponding  matching  sub-
          expressions in the regexp.

   t label
          If  a  s///  has done a successful substitution since the last input line was read and since the last t or T
          command, then branch to label; if label is omitted, branch to end of script.

   T label
          If no s/// has done a successful substitution since the last input line was read and since the last t  or  T
          command, then branch to label; if label is omitted, branch to end of script.  This is a GNU extension.

   w filename
          Write the current pattern space to filename.

   W filename
          Write the first line of the current pattern space to filename.  This is a GNU extension.

   x      Exchange the contents of the hold and pattern spaces.

   y/source/dest/
          Transliterate  the  characters in the pattern space which appear in source to the corresponding character in
          dest.
</code></pre>

<p>Addresses
       Sed commands can be given with no addresses, in which case the command will be executed for all input  lines;  with
       one  address, in which case the command will only be executed for input lines which match that address; or with two
       addresses, in which case the command will be executed for all input lines which match the inclusive range of  lines
       starting  from  the first address and continuing to the second address.  Three things to note about address ranges:
       the syntax is addr1,addr2 (i.e., the addresses are separated by a comma); the line which addr1 matched will  always
       be  accepted,  even  if  addr2 selects an earlier line; and if addr2 is a regexp, it will not be tested against the
       line that addr1 matched.</p>

<pre><code>   After the address (or address-range), and before the command, a !  may be inserted, which specifies that  the  com‐
   mand shall only be executed if the address (or address-range) does not match.

   The following address types are supported:

   number Match  only  the  specified line number (which increments cumulatively across files, unless the -s option is
          specified on the command line).

   first~step
          Match every step'th line starting with line first.  For example, ``sed -n 1~2p'' will print all the odd-num‐
          bered  lines in the input stream, and the address 2~5 will match every fifth line, starting with the second.
          first can be zero; in this case, sed operates as if it were equal to step.  (This is an extension.)

   $      Match the last line.

   /regexp/
          Match lines matching the regular expression regexp.

   \cregexpc
          Match lines matching the regular expression regexp.  The c may be any character.

   GNU sed also supports some special 2-address forms:

   0,addr2
          Start out in "matched first address" state, until addr2 is found.  This is similar to 1,addr2,  except  that
          if  addr2 matches the very first line of input the 0,addr2 form will be at the end of its range, whereas the
          1,addr2 form will still be at the beginning of its range.  This works only when addr2 is a  regular  expres‐
          sion.

   addr1,+N
          Will match addr1 and the N lines following addr1.

   addr1,~N
          Will  match addr1 and the lines following addr1 until the next line whose input line number is a multiple of
          N.
</code></pre>

<p>REGULAR EXPRESSIONS
       POSIX.2 BREs should be supported, but they aren&rsquo;t completely because of performance problems.  The \n sequence in a
       regular expression matches the newline character, and similarly for \a, \t, and other sequences.</p>

<p>BUGS
       E-mail  bug  reports  to <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x62;&#117;&#x67;&#45;&#115;&#101;&#x64;&#64;&#103;&#x6e;&#117;&#46;&#111;&#114;&#x67;&#46;">&#98;&#x75;&#103;&#45;&#x73;&#101;&#x64;&#64;&#103;&#x6e;&#x75;&#x2e;&#111;&#x72;&#103;&#x2e;</a>  Also, please include the output of &ldquo;sed &ndash;version&rdquo; in the body of your
       report if at all possible.</p>

<p>AUTHOR
       Written by Jay Fenlason, Tom Lord, Ken Pizzini, and Paolo Bonzini.  GNU sed  home  page:  &lt;<a href="http://www.gnu.org/soft%E2%80%90">http://www.gnu.org/soft%E2%80%90</a>
       ware/sed/>.   General  help  using  GNU  software:  <a href="http://www.gnu.org/gethelp/">http://www.gnu.org/gethelp/</a>.   E-mail  bug  reports to: <bug-
       sed@gnu.org>.  Be sure to include the word &ldquo;sed&rdquo; somewhere in the &ldquo;Subject:&rdquo; field.</p>

<p>COPYRIGHT
       Copyright  ©  2012  Free  Software   Foundation,   Inc.    License   GPLv3+:   GNU   GPL   version   3   or   later
       <a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>.
       This  is  free software: you are free to change and redistribute it.  There is NO WARRANTY, to the extent permitted
       by law.</p>

<p>SEE ALSO
       awk(1), ed(1), grep(1), tr(1), perlre(1), sed.info, any of various books on sed, the sed FAQ
       (<a href="http://sed.sf.net/grabbag/tutorials/sedfaq.txt">http://sed.sf.net/grabbag/tutorials/sedfaq.txt</a>), <a href="http://sed.sf.net/grabbag/.">http://sed.sf.net/grabbag/.</a></p>

<pre><code>   The full documentation for sed is maintained as a Texinfo manual.  If the info and sed programs are properly
   installed at your site, the command

          info sed

   should give you access to the complete manual.
</code></pre>

<p>sed 4.2.2                                                June 2013                                                  SED(1)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux-有用的命令]]></title>
    <link href="http://me.94313.net/blog/2014/08/31/linux-useful-command/"/>
    <updated>2014-08-31T18:57:18+08:00</updated>
    <id>http://me.94313.net/blog/2014/08/31/linux-useful-command</id>
    <content type="html"><![CDATA[<p>下面我将和大家分享一些学习Linux命令行的技巧，希望能对大家有所助益。如果在本文中遇到不太熟悉的命令，可以在终端中键入以下命令寻求帮助。
Man <command>
 Linux入门必备
了解bash：没有必要钻研长篇累牍的bash使用手册，通过man bash学习即可。
了解vi：你在工作中也许会使用Emacs或Eclipse，但vi不可替代。
了解ssh：学习无密码验证的基础知识。
bash作业管理基础知识：如使用&amp;、Ctrl-C、fg、bg、Ctrl-Z、jobs和kill等。
文件管理命令：如硬链接和软链接，权限等。
网络管理命令：如ifconfig等。
如何使用正则表达式，如何使用grep、sed等。
学习使用apt-get和yum管理软件包。
提升日常工作效率</p>

<p>在bash中，可以使用Ctrl+R命令搜索命令行历史记录。
在bash中，可以使用Ctrl+W删除最后一个单词，使用Ctrl+U删除整行。
使用cd -命令返回之前的工作目录，使用cd ..命令返回上层目录。
学习如何使用xargs：
$ find . -name *.py | xargs grep some_function<br/>
$ cat hosts | xargs -I{} ssh root@{} hostnameX
使用pstree -p命令查看进程树。
了解不同的信号。例如，使用kill -STOP [PID]终止进程。详细的信号列表可以在man 7 signal中查看。
如果你想让进程永远在后台运行，可以使用nohup和disown命令。
使用netstat -lntp命令查看侦听进程，并参考lsof命令。
在bash脚本中使用subshells对命令进行分组：</p>

<h1>do something in current dir</h1>

<p>(cd /some/other/dir; other-command)</p>

<h1>continue in original dir</h1>

<p>字符串修剪（Trimming Strings）：${var%suffix}和${var#prefix}。例如if var=foo.pdf then echo ${var%.pdf}.txt prints &ldquo;foo.txt&#8221;。
命令的输出可以当做文件使用。例如，比较本地和远程的/etc/hosts文件：
diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)
了解bash中的“here documents”。
了解标准输出和标准错误重定向。
了解ASCII代码表。可以在终端中运行man ascii命令作为参考。
当通过ssh远程工作时，可以使用screen 或 dtach保存回话。
对Web开发者而言，curl、wget等命令非常实用。
将HTML页面转化文本文件：
lynx -dump -stdin
如果要掌握XML，xmlstarlet命令是非常好的工具。
了解ssh端口映射。
使用Alt+shift+3快捷键可以在行前添加注释“#”。
数据处理</p>

<p>了解sort和uniq命令。
了解cut、paste和join命令。
了解如何对文本文件做交集、并集和差集：
cat a b | sort | uniq > c # c is a union b<br/>
cat a b | sort | uniq -d > c # c is a intersect b<br/>
cat a b b | sort | uniq -u > c # c is set difference a – b
对文本文件的第二列做摘要，下面的代码要比同样的Python代码更精炼、快速（3倍）：
awk &lsquo;{ x += $2 } END { print x }&rsquo;
了解字符串和grep命令。
文件分割：了解split（按大小分割）和csplit（按匹配分割）命令。
系统诊断</p>

<p>使用iostat、netstat、top和dstat命令查看磁盘、处理器和网络的状态。
使用free、vmstat等命令了解系统内存状态。
使用mtr网络诊断工具。
使用iftop、nethogs等工具查看占用带宽的进程和带宽。
使用ab工具快速洞悉Web服务器的性能。
以wireshark和tshark命令应对复杂网络诊断。
学习如何使用strace，并用于诊断运行的进程。这对分析程序运行错误的原因，非常有帮助。
使用ldd命令查看共享库文件。
了解如何使用gdb连接到运行中的进程，并进行堆栈跟踪。
有关/proc的知识非常重要。
如何诊断已发生的错误？Sar命令是一种很好的选择，它可以收集、保存并报告系统信息。</p>
]]></content>
  </entry>
  
</feed>
