<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[学会欣赏]]></title>
  <link href="http://me.94313.net/atom.xml" rel="self"/>
  <link href="http://me.94313.net/"/>
  <updated>2015-07-06T14:40:23+08:00</updated>
  <id>http://me.94313.net/</id>
  <author>
    <name><![CDATA[wuchangqian]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Htop是个好东西]]></title>
    <link href="http://me.94313.net/blog/2015/01/06/htop/"/>
    <updated>2015-01-06T13:49:16+08:00</updated>
    <id>http://me.94313.net/blog/2015/01/06/htop</id>
    <content type="html"><![CDATA[<pre><code>Htop是一款运行于Linux系统监控与进程管理软件，用于取代Unix下传统的top。与top只提供最消耗资源的进程列表不同，htop提供所有进程的列表，并且使用彩色标识出处理器、swap和内存状态。
</code></pre>

<p>用户一般可以在top无法提供详尽系统信息的情况下选择安装并使用htop。比如，在查找应用程序的内存泄漏问题时。与top相比，htop提供更方便、光标控制的界面来杀死进程。
htop用C语言编写，采用了ncurses库。htop的名称源于其作者的名字。</p>

<h2>安装</h2>

<pre><code>yum -y install ncurses-devel #htop依赖ncurses
cd /opt
wget -c http://ncu.dl.sourceforge.net/project/htop/htop/1.0.2/htop-1.0.2.tar.gz
tar xzf htop-1.0.2.tar.gz
cd htop-1.0.2
./configure
make &amp;&amp; make install
</code></pre>

<h2>示例图片</h2>

<p><img src="../images/2015/htop.gif" title="示例图片" alt="示例图片" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css-clearfix]]></title>
    <link href="http://me.94313.net/blog/2014/10/19/css-clearfix/"/>
    <updated>2014-10-19T11:20:41+08:00</updated>
    <id>http://me.94313.net/blog/2014/10/19/css-clearfix</id>
    <content type="html"><![CDATA[<pre><code>&lt;style&gt;
.clearfix:after{
    visibility: hidden;
    display: block;
    font-size: 0;
    content: ".";
    clear: both;
    height: 0;
}

* html .clearfix{zoom: 1;}
*:first-child + html .clearfix{zoom: 1;}
&lt;/style&gt;
&lt;div class="clearfix" style="border: 2px solid red;"&gt;
    &lt;div style="float: left; width: 80px; height: 80px; border: 1px solid blue;"&gt;TEST DIV&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<h3>说明：</h3>

<ol>
<li>首先是利用:after这个伪类来兼容FF、Chrome等支持标准的浏览器。:after伪类IE不支持，它用来和content属性一起使用设置在对象后的内容，例如：a:after{content:&ldquo;(link)&rdquo;;}这个CSS将会让a标签内的文本后边加上link文本文字。</li>
<li>利用“* html”这个只有IE6认识的选择符，设置缩放属性“zoom: 1;”实现兼容IE6。</li>
<li>利用“*:first-child + html”这个只有IE7认识的选择符，设置缩放属性“zoom: 1;”实现兼容IE7。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[经营一个网站需要哪些牌照资质]]></title>
    <link href="http://me.94313.net/blog/2014/10/19/wangzhan-paizhao/"/>
    <updated>2014-10-19T10:58:37+08:00</updated>
    <id>http://me.94313.net/blog/2014/10/19/wangzhan-paizhao</id>
    <content type="html"><![CDATA[<ul>
<li>信息产业部ICP备案,主要是针对非经营性网站，任何一个在国内的网站都要备案。审批机构：工业与信息化部</li>
<li>电信与信息服务业务经营许可证(ICP)主要是针对经营性互联网信息服务网站，注册资金要求100万以上，北京的证叫这个名字，全国其它地方的证的名称为“增值电信业务经营许可证”，经营范围为 互联网信息服务业务。审批机构：各地通信管理局</li>
<li>电子公告服务:电信业务审批主要是针对设有电子公告服务(bbs)论坛网站。审批机构：各 地通信管理局</li>
<li>经营性网站备案,经营性网站备案，是指经营性网站向工商行政管理机关申请备案，工商行政管 理机关在网站的首页上加贴经营性网站备案电子标识，并将备案信息向社会公开。审批机构：北京市工商行政管理局</li>
<li>增值电信业务经营许可证(移动网信息服务业务SP)主要是针对提供移动网无线增值信息服 务业务需要办理的。审批机构：各地通信管理局</li>
<li>互联网新闻信息服务许可证主要针对从事登载新闻业务的网站。审批机构：国务院新闻办</li>
<li>网络文化经营许可证主要针对经营互联网文化产品和提供互联网文化产品及其服务的网站。审批机构：省级文化行政部门（2010.08.01日开始下放到省级）</li>
<li>互联网药品信息服务资格证书主要针对经营互联网药品信息服务的网站。审批机构：北京 市药品监督管理局</li>
<li>互联网出版许可证主要针对经营互联网出版类电子商务业务的网站。审批机构：新闻出版总署</li>
<li>网络视听节目传播许可证（有新旧之分，新的目前据传只有5家）信息网络视听节目许可证》由广电总局按照信息网络传播视听节目的业务类别、接收终端、传输网络等项目分类核发。 审批机构：广电总局</li>
<li>互联网卫生信息服务管理主要针对经营互联网卫生信息服务业务的网站。审批机构：北京市卫生局</li>
<li>电子支付牌照（即将推出）主要是对电子支付企业实行牌照制度，传闻在今年第一季度发放，大概包括支付宝在内的10家公司可获得牌照。 审批机构：中国人民银行</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL 的 Prompt 转义字符]]></title>
    <link href="http://me.94313.net/blog/2014/10/19/mysql-shell-prompt-metachar/"/>
    <updated>2014-10-19T10:53:38+08:00</updated>
    <id>http://me.94313.net/blog/2014/10/19/mysql-shell-prompt-metachar</id>
    <content type="html"><![CDATA[<pre><code>\c    ：A counter that increments for each statement you issue
\D    ：The full current date
\d    ：The default database
\h    ：The server host
\l    ：The current delimiter (new in 5.1.12)
\m    ：Minutes of the current time
\n    ：A newline character
\O    ：The current month in three-letter format (Jan, Feb, …)
\o    ：The current month in numeric format
\P    ：am/pm
\p    ：The current TCP/IP port or socket file
\R    ：The current time, in 24-hour military time (0–23)
\r    ：The current time, standard 12-hour time (1–12)
\S    ：Semicolon
\s    ：Seconds of the current time
\t    ：A tab character
\U    ：Your full user_name@host_name account name
\u    ：Your user name
\v    ：The server version
\w    ：The current day of the week in three-letter format (Mon, Tue, …)
\Y    ：The current year, four digits
\y    ：The current year, two digits
\_    ：A space
\A    ：space (a space follows the backslash)
\'    ：Single quote
\"    ：Double quote
\\    ：A literal “\” backslash character
\x    ：x, for any “x” not listed above
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sed-man-page]]></title>
    <link href="http://me.94313.net/blog/2014/09/01/sed-man-page/"/>
    <updated>2014-09-01T18:30:03+08:00</updated>
    <id>http://me.94313.net/blog/2014/09/01/sed-man-page</id>
    <content type="html"><![CDATA[<p>NAME</p>

<pre><code>   sed - stream editor for filtering and transforming text
</code></pre>

<p>SYNOPSIS</p>

<pre><code>   sed [OPTION]... {script-only-if-no-other-script} [input-file]...
</code></pre>

<p>DESCRIPTION</p>

<pre><code>   Sed  is  a stream editor.  A stream editor is used to perform basic text transformations on an input stream (a file
   or input from a pipeline).  While in some ways similar to an editor which permits scripted edits (such as ed),  sed
   works  by  making  only one pass over the input(s), and is consequently more efficient.  But it is sed's ability to
   filter text in a pipeline which particularly distinguishes it from other types of editors.

   -n, --quiet, --silent

          suppress automatic printing of pattern space

   -e script, --expression=script

          add the script to the commands to be executed

   -f script-file, --file=script-file

          add the contents of script-file to the commands to be executed

   --follow-symlinks

          follow symlinks when processing in place

   -i[SUFFIX], --in-place[=SUFFIX]

          edit files in place (makes backup if SUFFIX supplied)

   -b, --binary

          open files in binary mode (CR+LFs are not processed specially)

   -l N, --line-length=N

          specify the desired line-wrap length for the `l' command

   --posix

          disable all GNU extensions.

   -r, --regexp-extended

          use extended regular expressions in the script.

   -s, --separate

          consider files as separate rather than as a single continuous long stream.

   -u, --unbuffered

          load minimal amounts of data from the input files and flush the output buffers more often

   -z, --null-data

          separate lines by NUL characters

   --help
          display this help and exit

   --version
          output version information and exit

   If no -e, --expression, -f, or --file option is given, then the first non-option  argument  is  taken  as  the  sed
   script  to  interpret.  All remaining arguments are names of input files; if no input files are specified, then the
   standard input is read.

   GNU sed home page: &lt;http://www.gnu.org/software/sed/&gt;.  General help using GNU software:  &lt;http://www.gnu.org/geth‐
   elp/&gt;.   E-mail  bug  reports  to:  &lt;bug-sed@gnu.org&gt;.  Be sure to include the word ``sed'' somewhere in the ``Sub‐
   ject:'' field.
</code></pre>

<p>COMMAND SYNOPSIS</p>

<pre><code>   This is just a brief synopsis of sed commands to serve as a reminder to those who already know sed; other  documen‐
   tation (such as the texinfo document) must be consulted for fuller descriptions.
</code></pre>

<p>   Zero-address &ldquo;commands&rdquo;</p>

<pre><code>   : label
          Label for b and t commands.

   #comment
          The comment extends until the next newline (or the end of a -e script fragment).

   }      The closing bracket of a { } block.
</code></pre>

<p>   Zero- or One- address commands</p>

<pre><code>   =      Print the current line number.

   a \

   text   Append text, which has each embedded newline preceded by a backslash.

   i \

   text   Insert text, which has each embedded newline preceded by a backslash.

   q [exit-code]
          Immediately quit the sed script without processing any more input, except that if auto-print is not disabled
          the current pattern space will be printed.  The exit code argument is a GNU extension.

   Q [exit-code]
          Immediately quit the sed script without processing any more input.  This is a GNU extension.

   r filename
          Append text read from filename.

   R filename
          Append a line read from filename.  Each invocation of the command reads a line from the file.  This is a GNU
          extension.
</code></pre>

<p>   Commands which accept address ranges</p>

<pre><code>   {      Begin a block of commands (end with a }).

   b label
          Branch to label; if label is omitted, branch to end of script.

   c \

   text   Replace the selected lines with text, which has each embedded newline preceded by a backslash.

   d      Delete pattern space.  Start next cycle.

   D      If  pattern  space contains no newline, start a normal new cycle as if the d command was issued.  Otherwise,
          delete text in the pattern space up to the first newline, and  restart  cycle  with  the  resultant  pattern
          space, without reading a new line of input.

   h H    Copy/append pattern space to hold space.

   g G    Copy/append hold space to pattern space.

   l      List out the current line in a ``visually unambiguous'' form.

   l width
          List  out  the  current line in a ``visually unambiguous'' form, breaking it at width characters.  This is a
          GNU extension.

   n N    Read/append the next line of input into the pattern space.

   p      Print the current pattern space.

   P      Print up to the first embedded newline of the current pattern space.

   s/regexp/replacement/
          Attempt to match regexp against the pattern  space.   If  successful,  replace  that  portion  matched  with
          replacement.   The  replacement  may contain the special character &amp; to refer to that portion of the pattern
          space which matched, and the special escapes \1 through \9 to  refer  to  the  corresponding  matching  sub-
          expressions in the regexp.

   t label
          If  a  s///  has done a successful substitution since the last input line was read and since the last t or T
          command, then branch to label; if label is omitted, branch to end of script.

   T label
          If no s/// has done a successful substitution since the last input line was read and since the last t  or  T
          command, then branch to label; if label is omitted, branch to end of script.  This is a GNU extension.

   w filename
          Write the current pattern space to filename.

   W filename
          Write the first line of the current pattern space to filename.  This is a GNU extension.

   x      Exchange the contents of the hold and pattern spaces.

   y/source/dest/
          Transliterate  the  characters in the pattern space which appear in source to the corresponding character in
          dest.
</code></pre>

<p>Addresses</p>

<pre><code>   Sed commands can be given with no addresses, in which case the command will be executed for all input  lines;  with
   one  address, in which case the command will only be executed for input lines which match that address; or with two
   addresses, in which case the command will be executed for all input lines which match the inclusive range of  lines
   starting  from  the first address and continuing to the second address.  Three things to note about address ranges:
   the syntax is addr1,addr2 (i.e., the addresses are separated by a comma); the line which addr1 matched will  always
   be  accepted,  even  if  addr2 selects an earlier line; and if addr2 is a regexp, it will not be tested against the
   line that addr1 matched.

   After the address (or address-range), and before the command, a !  may be inserted, which specifies that  the  com‐
   mand shall only be executed if the address (or address-range) does not match.

   The following address types are supported:

   number Match  only  the  specified line number (which increments cumulatively across files, unless the -s option is
          specified on the command line).

   first~step
          Match every step'th line starting with line first.  For example, ``sed -n 1~2p'' will print all the odd-num‐
          bered  lines in the input stream, and the address 2~5 will match every fifth line, starting with the second.
          first can be zero; in this case, sed operates as if it were equal to step.  (This is an extension.)

   $      Match the last line.

   /regexp/
          Match lines matching the regular expression regexp.

   \cregexpc
          Match lines matching the regular expression regexp.  The c may be any character.

   GNU sed also supports some special 2-address forms:

   0,addr2
          Start out in "matched first address" state, until addr2 is found.  This is similar to 1,addr2,  except  that
          if  addr2 matches the very first line of input the 0,addr2 form will be at the end of its range, whereas the
          1,addr2 form will still be at the beginning of its range.  This works only when addr2 is a  regular  expres‐
          sion.

   addr1,+N
          Will match addr1 and the N lines following addr1.

   addr1,~N
          Will  match addr1 and the lines following addr1 until the next line whose input line number is a multiple of
          N.
</code></pre>

<p>REGULAR EXPRESSIONS</p>

<pre><code>   POSIX.2 BREs should be supported, but they aren't completely because of performance problems.  The \n sequence in a
   regular expression matches the newline character, and similarly for \a, \t, and other sequences.
</code></pre>

<p>BUGS</p>

<pre><code>   E-mail  bug  reports  to bug-sed@gnu.org.  Also, please include the output of ``sed --version'' in the body of your
   report if at all possible.
</code></pre>

<p>AUTHOR</p>

<pre><code>   Written by Jay Fenlason, Tom Lord, Ken Pizzini, and Paolo Bonzini.  GNU sed  home  page:  &lt;http://www.gnu.org/soft‐
   ware/sed/&gt;.   General  help  using  GNU  software:  &lt;http://www.gnu.org/gethelp/&gt;.   E-mail  bug  reports to: &lt;bug-
   sed@gnu.org&gt;.  Be sure to include the word ``sed'' somewhere in the ``Subject:'' field.
</code></pre>

<p>COPYRIGHT</p>

<pre><code>   Copyright  ©  2012  Free  Software   Foundation,   Inc.    License   GPLv3+:   GNU   GPL   version   3   or   later
   &lt;http://gnu.org/licenses/gpl.html&gt;.
   This  is  free software: you are free to change and redistribute it.  There is NO WARRANTY, to the extent permitted
   by law.
</code></pre>

<p>SEE ALSO</p>

<pre><code>   awk(1), ed(1), grep(1), tr(1), perlre(1), sed.info, any of various books on sed, the sed FAQ
   (http://sed.sf.net/grabbag/tutorials/sedfaq.txt), http://sed.sf.net/grabbag/.

   The full documentation for sed is maintained as a Texinfo manual.  If the info and sed programs are properly
   installed at your site, the command

          info sed

   should give you access to the complete manual.
</code></pre>

<p>sed 4.2.2                                                June 2013                                                  SED(1)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[html-DocType]]></title>
    <link href="http://me.94313.net/blog/2014/08/31/html-doctype/"/>
    <updated>2014-08-31T19:29:52+08:00</updated>
    <id>http://me.94313.net/blog/2014/08/31/html-doctype</id>
    <content type="html"><![CDATA[<p>&lt;!doctype html></p>

<ol>
<li>所有浏览器都支持 &lt;!DOCTYPE> 声明。</li>
<li>&lt;!DOCTYPE> 声明必须是 HTML 文档的第一行，位于 <html> 标签之前。</li>
<li>&lt;!DOCTYPE> 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。</li>
<li>在 HTML 4.01 中，&lt;!DOCTYPE> 声明引用 DTD，因为 HTML 4.01 基于 SGML。</li>
<li>DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。</li>
<li>HTML5 不基于 SGML，所以不需要引用 DTD。</li>
<li>&lt;!DOCTYPE> 声明没有结束标签。</li>
<li>&lt;!DOCTYPE> 声明对大小写不敏感。</li>
</ol>


<p>提示：请始终向 HTML 文档添加 &lt;!DOCTYPE> 声明，这样浏览器才能获知文档类型。</p>

<ul>
<li>HTML        1991</li>
<li>HTML+       1993</li>
<li>HTML 2.0    1995</li>
<li>HTML 3.2    1997</li>
<li>HTML 4.01   1999</li>
<li>XHTML 1.0   2000</li>
<li>HTML5       2012</li>
<li>XHTML5      2013</li>
</ul>


<p>常用的 DOCTYPE 声明如下
HTML 5
&lt;!DOCTYPE html></p>

<h3>HTML 4.01 Strict</h3>

<p>该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。
&lt;!DOCTYPE HTML PUBLIC &ldquo;&ndash;//W3C//DTD HTML 4.01//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/html4/strict.dtd">http://www.w3.org/TR/html4/strict.dtd</a>&rdquo;></p>

<h3>HTML 4.01 Transitional</h3>

<p>该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。
&lt;!DOCTYPE HTML PUBLIC &ldquo;&ndash;//W3C//DTD HTML 4.01 Transitional//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/html4/loose.dtd">http://www.w3.org/TR/html4/loose.dtd</a>&rdquo;></p>

<h3>HTML 4.01 Frameset</h3>

<p>该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。
&lt;!DOCTYPE HTML PUBLIC &ldquo;&ndash;//W3C//DTD HTML 4.01 Frameset//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/html4/frameset.dtd">http://www.w3.org/TR/html4/frameset.dtd</a>&rdquo;></p>

<h3>XHTML 1.0 Strict</h3>

<p>该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。
&lt;!DOCTYPE html PUBLIC &ldquo;&ndash;//W3C//DTD XHTML 1.0 Strict//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</a>&rdquo;></p>

<h3>XHTML 1.0 Transitional</h3>

<p>该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。
&lt;!DOCTYPE html PUBLIC &ldquo;&ndash;//W3C//DTD XHTML 1.0 Transitional//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd</a>&rdquo;></p>

<h3>XHTML 1.0 Frameset</h3>

<p>该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。
&lt;!DOCTYPE html PUBLIC &ldquo;&ndash;//W3C//DTD XHTML 1.0 Frameset//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd</a>&rdquo;></p>

<h3>XHTML 1.1</h3>

<p>该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。
&lt;!DOCTYPE html PUBLIC &ldquo;&ndash;//W3C//DTD XHTML 1.1//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd</a>&rdquo;></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux-有用的命令]]></title>
    <link href="http://me.94313.net/blog/2014/08/31/linux-useful-command/"/>
    <updated>2014-08-31T18:57:18+08:00</updated>
    <id>http://me.94313.net/blog/2014/08/31/linux-useful-command</id>
    <content type="html"><![CDATA[<p>下面我将和大家分享一些学习Linux命令行的技巧，希望能对大家有所助益。如果在本文中遇到不太熟悉的命令，可以在终端中键入以下命令寻求帮助。
Man <command>
 Linux入门必备
了解bash：没有必要钻研长篇累牍的bash使用手册，通过man bash学习即可。
了解vi：你在工作中也许会使用Emacs或Eclipse，但vi不可替代。
了解ssh：学习无密码验证的基础知识。
bash作业管理基础知识：如使用&amp;、Ctrl-C、fg、bg、Ctrl-Z、jobs和kill等。
文件管理命令：如硬链接和软链接，权限等。
网络管理命令：如ifconfig等。
如何使用正则表达式，如何使用grep、sed等。
学习使用apt-get和yum管理软件包。
提升日常工作效率</p>

<p>在bash中，可以使用Ctrl+R命令搜索命令行历史记录。
在bash中，可以使用Ctrl+W删除最后一个单词，使用Ctrl+U删除整行。
使用cd -命令返回之前的工作目录，使用cd ..命令返回上层目录。
学习如何使用xargs：
$ find . -name *.py | xargs grep some_function<br/>
$ cat hosts | xargs -I{} ssh root@{} hostnameX
使用pstree -p命令查看进程树。
了解不同的信号。例如，使用kill -STOP [PID]终止进程。详细的信号列表可以在man 7 signal中查看。
如果你想让进程永远在后台运行，可以使用nohup和disown命令。
使用netstat -lntp命令查看侦听进程，并参考lsof命令。
在bash脚本中使用subshells对命令进行分组：</p>

<h1>do something in current dir</h1>

<p>(cd /some/other/dir; other-command)</p>

<h1>continue in original dir</h1>

<p>字符串修剪（Trimming Strings）：${var%suffix}和${var#prefix}。例如if var=foo.pdf then echo ${var%.pdf}.txt prints &ldquo;foo.txt&#8221;。
命令的输出可以当做文件使用。例如，比较本地和远程的/etc/hosts文件：
diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)
了解bash中的“here documents”。
了解标准输出和标准错误重定向。
了解ASCII代码表。可以在终端中运行man ascii命令作为参考。
当通过ssh远程工作时，可以使用screen 或 dtach保存回话。
对Web开发者而言，curl、wget等命令非常实用。
将HTML页面转化文本文件：
lynx -dump -stdin
如果要掌握XML，xmlstarlet命令是非常好的工具。
了解ssh端口映射。
使用Alt+shift+3快捷键可以在行前添加注释“#”。
数据处理</p>

<p>了解sort和uniq命令。
了解cut、paste和join命令。
了解如何对文本文件做交集、并集和差集：
cat a b | sort | uniq > c # c is a union b<br/>
cat a b | sort | uniq -d > c # c is a intersect b<br/>
cat a b b | sort | uniq -u > c # c is set difference a – b
对文本文件的第二列做摘要，下面的代码要比同样的Python代码更精炼、快速（3倍）：
awk &lsquo;{ x += $2 } END { print x }&rsquo;
了解字符串和grep命令。
文件分割：了解split（按大小分割）和csplit（按匹配分割）命令。
系统诊断</p>

<p>使用iostat、netstat、top和dstat命令查看磁盘、处理器和网络的状态。
使用free、vmstat等命令了解系统内存状态。
使用mtr网络诊断工具。
使用iftop、nethogs等工具查看占用带宽的进程和带宽。
使用ab工具快速洞悉Web服务器的性能。
以wireshark和tshark命令应对复杂网络诊断。
学习如何使用strace，并用于诊断运行的进程。这对分析程序运行错误的原因，非常有帮助。
使用ldd命令查看共享库文件。
了解如何使用gdb连接到运行中的进程，并进行堆栈跟踪。
有关/proc的知识非常重要。
如何诊断已发生的错误？Sar命令是一种很好的选择，它可以收集、保存并报告系统信息。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apache处理http请求的生命周期]]></title>
    <link href="http://me.94313.net/blog/2014/08/31/apache-http-request-process/"/>
    <updated>2014-08-31T09:49:40+08:00</updated>
    <id>http://me.94313.net/blog/2014/08/31/apache-http-request-process</id>
    <content type="html"><![CDATA[<p>Apache请求处理循环的11个阶段都做了哪些事情呢？</p>

<ol>
<li>Post-Read-Request阶段: 在正常请求处理流程中，这是模块可以插入钩子的第一个阶段。对于那些想很早进入处理请求的模块来说，这个阶段可以被利用。</li>
<li>URI Translation阶段 :  Apache在本阶段的主要工作：将请求的URL映射到本地文件系统。模块可以在这阶段插入钩子，执行自己的映射逻辑。mod_alias就是利用这个阶段工作的。</li>
<li>Header Parsing阶段 : Apache在本阶段的主要工作：检查请求的头部。由于模块可以在请求处理流程的任何一个点上执行检查请求头部的任务，因此这个钩子很少被使用。mod_setenvif就是利用这个阶段工作的。</li>
<li>Access Control阶段 :  Apache在本阶段的主要工作：根据配置文件检查是否允许访问请求的资源。Apache的标准逻辑实现了允许和拒绝指令。mod_authz_host就是利用这个阶段工作的。</li>
<li>Authentication阶段 :  Apache在本阶段的主要工作：按照配置文件设定的策略对用户进行认证，并设定用户名区域。模块可以在这阶段插入钩子，实现一个认证方法。</li>
<li>Authorization阶段 :  Apache在本阶段的主要工作：根据配置文件检查是否允许认证过的用户执行请求的操作。模块可以在这阶段插入钩子，实现一个用户权限管理的方法。</li>
<li>MIME Type Checking阶段 :  Apache在本阶段的主要工作：根据请求资源的MIME类型的相关规则，判定将要使用的内容处理函数。标准模块mod_negotiation和mod_mime实现了这个钩子。</li>
<li>FixUp阶段 :  这是一个通用的阶段，允许模块在内容生成器之前，运行任何必要的处理流程。和Post_Read_Request类似，这是一个能够捕获任何信息的钩子，也是最常使用的钩子。</li>
<li>Response阶段 : Apache在本阶段的主要工作：生成返回客户端的内容，负责给客户端发送一个恰当的回复。这个阶段是整个处理流程的核心部分。</li>
<li>Logging阶段 :  Apache在本阶段的主要工作：在回复已经发送给客户端之后记录事务。模块可能修改或者替换Apache的标准日志记录。</li>
<li>CleanUp阶段 : Apache在本阶段的主要工作：清理本次请求事务处理完成之后遗留的环境，比如文件、目录的处理或者Socket的关闭等等，这是Apache一次请求处理的最后一个阶段。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP Break 关键字]]></title>
    <link href="http://me.94313.net/blog/2014/08/31/php-break-keywork/"/>
    <updated>2014-08-31T09:26:19+08:00</updated>
    <id>http://me.94313.net/blog/2014/08/31/php-break-keywork</id>
    <content type="html"><![CDATA[<p>php的break关键字可以接受一个可选的数字参数来决定跳出几重循环
break 结束当前 for，foreach，while，do-while 或者 switch 结构的执行。
break可以接受一个可选的数字参数来决定跳出几重循环。</p>

<pre><code>&lt;?php
    $arr = array('one', 'two', 'three', 'four', 'stop', 'five');
    while (list (, $val) = each($arr)) {
        if ($val == 'stop') {
            break;    /* You could also write 'break 1;' here. */
        }
        echo "$val&lt;br /&gt;\n";
    }

    /* Using the optional argument. */

    $i = 0;
    while (++$i) {
        switch ($i) {
        case 5:
            echo "At 5&lt;br /&gt;\n";
            break 1;  /* Exit only the switch. */
        case 10:
            echo "At 10; quitting&lt;br /&gt;\n";
            break2;  /* Exit the switch and the while. */
        default:
            break;
        }
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress添加分类到侧边栏]]></title>
    <link href="http://me.94313.net/blog/2014/05/20/octopress-add-category2rightaside/"/>
    <updated>2014-05-20T23:02:11+08:00</updated>
    <id>http://me.94313.net/blog/2014/05/20/octopress-add-category2rightaside</id>
    <content type="html"><![CDATA[<h2>增加category_list插件</h2>

<p>保存以下代码到plugins/category_list_tag.rb：</p>

<pre><code>module Jekyll
  class CategoryListTag &lt; Liquid::Tag
    def render(context)
      html = ""
      categories = context.registers[:site].categories.keys
      categories.sort.each do |category|
        posts_in_category = context.registers[:site].categories[category].size
        category_dir = context.registers[:site].config['category_dir']
        category_url = File.join(category_dir, category.gsub(/_|\P{Word}/, '-').gsub(/-{2,}/, '-').downcase)
        html &lt;&lt; "&lt;li class='category'&gt;&lt;a href='http://me.94313.net/#{category_url}/'&gt;#{category} (#{posts_in_category})&lt;/a&gt;&lt;/li&gt;\n"
      end
      html
    end
  end
end
</code></pre>

<p>Liquid::Template.register_tag(&lsquo;category_list&rsquo;, Jekyll::CategoryListTag)<br/>
这个插件会向liquid注册一个名为category_list的tag，该tag就是以li的形式将站点所有的category组织起来。如果要将category加入到侧边导航栏，需要增加一个aside。</p>

<h2>增加aside</h2>

<p>复制以下代码到source/_includes/asides/category_list.html。</p>

<pre><code>&lt;section&gt;
  &lt;h1&gt;Categories&lt;/h1&gt;
  &lt;ul id="categories"&gt;
    { % category_list % }
  &lt;/ul&gt;
&lt;/section&gt;
</code></pre>

<h2>配置侧边栏需要修改_config.yml文件，修改其default_asides项：</h2>

<p>default_asides: [asides/category_list.html, asides/recent_posts.html]<br/>
以上asides根据自己的需求调整。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一致性哈希算法浅析]]></title>
    <link href="http://me.94313.net/blog/2014/01/31/consistent-hashing/"/>
    <updated>2014-01-31T10:27:40+08:00</updated>
    <id>http://me.94313.net/blog/2014/01/31/consistent-hashing</id>
    <content type="html"><![CDATA[<p>在做服务器负载均衡时候可供选择的负载均衡的算法有很多，包括：</p>

<ul>
<li>轮循算法（Round Robin）</li>
<li>哈希算法（HASH）</li>
<li>最少连接算法（Least Connection）</li>
<li>响应速度算法（Response Time）</li>
<li>加权法（Weighted ）等</li>
</ul>


<p> 其中哈希算法是最为常用的算法.
典型的应用场景是： 有N台服务器提供缓存服务，需要对服务器进行负载均衡，将请求平均分发到每台服务器上，每台机器负责1/N的服务。
常用的算法是对hash结果取余数 (hash() mod N)：对机器编号从0到N-1，按照自定义的hash()算法，对每个请求的hash()值按N取模，得到余数i，然后将请求分发到编号为i的机器。但这样的算法方法存在致命问题，如果某一台机器宕机，那么应该落在该机器的请求就无法得到正确的处理，这时需要将当掉的服务器从算法从去除，此时候会有(N-1)/N的服务器的缓存数据需要重新进行计算；如果新增一台机器，会有N /(N+1)的服务器的缓存数据需要进行重新计算。对于系统而言，这通常是不可接受的颠簸（因为这意味着大量缓存的失效或者数据需要转移）。那么，如何设计一个负载均衡策略，使得受到影响的请求尽可能的少呢？
在Memcached、Key-Value Store、Bittorrent DHT、LVS中都采用了Consistent Hashing算法，可以说Consistent Hashing 是分布式系统负载均衡的首选算法。
1、Consistent Hashing算法描述
下面以Memcached中的Consisten Hashing算法为例说明。
由于hash算法结果一般为unsigned int型，因此对于hash函数的结果应该均匀分布在[0,232-1]间，如果我们把一个圆环用232 个点来进行均匀切割，首先按照hash(key)函数算出服务器（节点）的哈希值， 并将其分布到0～232的圆上。
用同样的hash(key)函数求出需要存储数据的键的哈希值，并映射到圆上。然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器（节点）上。</p>

<p><img src="http://me.94313.net/images/consistent-hashing-01.png" alt="consistent hashing" /></p>

<p>Consistent Hashing原理示意图
新增一个节点的时候，只有在圆环上新增节点逆时针方向的第一个节点的数据会受到影响。删除一个节点的时候，只有在圆环上原来删除节点顺时针方向的第一个节点的数据会受到影响，因此通过Consistent Hashing很好地解决了负载均衡中由于新增节点、删除节点引起的hash值颠簸问题。</p>

<p><img src="http://me.94313.net/images/consistent-hashing-02.png" alt="consistent hashing" /></p>

<p>Consistent Hashing添加服务器示意图
虚拟节点（virtual nodes）：之所以要引进虚拟节点是因为在服务器（节点）数较少的情况下（例如只有3台服务器），通过hash(key)算出节点的哈希值在圆环上并不是均匀分布的（稀疏的），仍然会出现各节点负载不均衡的问题。虚拟节点可以认为是实际节点的复制品（replicas），本质上与实际节点实际上是一样的（key并不相同）。引入虚拟节点后，通过将每个实际的服务器（节点）数按照一定的比例(例如200倍)扩大后并计算其hash(key)值以均匀分布到圆环上。在进行负载均衡时候，落到虚拟节点的哈希值实际就落到了实际的节点上。由于所有的实际节点是按照相同的比例复制成虚拟节点的，因此解决了节点数较少的情况下哈希值在圆环上均匀分布的问题。</p>

<p><img src="http://me.94313.net/images/consistent-hashing-03.png" alt="consistent hashing" /></p>

<p>虚拟节点对Consistent Hashing结果的影响
从上图可以看出，在节点数为10个的情况下，每个实际节点的虚拟节点数为实际节点的100-200倍的时候，结果还是很均衡的。</p>

<p>第3段中有这些文字：“但这样的算法方法存在致命问题，如果某一台机器宕机，那么应该落在该机器的请求就无法得到正确的处理，这时需要将当掉的服务器从算法从去除，此时候会有(N-1)/N的服务器的缓存数据需要重新进行计算；”
为何是 (N-1)/N 呢？解释如下：
  比如有 3 台机器，hash值 1-6 在这3台上的分布就是：
  host 1: 1 4
  host 2: 2 5
  host 3: 3 6
  如果挂掉一台，只剩两台，模数取 2 ，那么分布情况就变成：
  host 1: 1 3 5
  host 2: 2 4 6
可以看到，还在数据位置不变的只有2个： 1，2，位置发生改变的有4个，占共6个数据的比率是 4/6 = 2/3
这样的话，受影响的数据太多了，势必太多的数据需要重新从 DB 加载到 cache 中，严重影响性能</p>

<p>【consistent hashing 的办法】
上面提到的 hash 取模，模数取的比较小，一般是负载的数量，而 consistent hashing 的本质是将模数取的比较大，为 2的32次方减1，即一个最大的 32 位整数。然后，就可以从容的安排数据导向了，那个图还是挺直观的
以下部分为一致性哈希算法的一种PHP实现。
下载地址 ：<a href="http://zwzweb.googlecode.com/files/Consistent%20Hashing.php">http://zwzweb.googlecode.com/files/Consistent%20Hashing.php</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery.extend()函数注释说明]]></title>
    <link href="http://me.94313.net/blog/2013/08/30/jquery-extend-method/"/>
    <updated>2013-08-30T14:11:50+08:00</updated>
    <id>http://me.94313.net/blog/2013/08/30/jquery-extend-method</id>
    <content type="html"><![CDATA[<ul>
<li>// 第一个参数是true，则会迭代合并</li>
<li>// 合并两个或更多对象的属性到第一个对象中，jQuery后续的大部分功能都通过该函数扩展</li>
<li>// 通过jQuery.fn.extend扩展的函数，大部分都会调用通过jQuery.extend扩展的同名函数</li>
<li>// 如果传入两个或多个对象，所有对象的属性会被添加到第一个对象target</li>
<li>// 如果只传入一个对象，则将对象的属性添加到jQuery对象中。</li>
<li>// 用这种方式，我们可以为jQuery命名空间增加新的方法。可以用于编写jQuery插件。</li>
<li>// 如果不想改变传入的对象，可以传入一个空对象：$.extend({}, object1, object2);</li>
<li>// 默认合并操作是不迭代的，即便target的某个属性是对象或属性，也会被完全覆盖而不是合并</li>
<li>// 从object原型继承的属性会被拷贝</li>
<li>// undefined值不会被拷贝</li>
<li>// 因为性能原因，JavaScript自带类型的属性不会合并</li>
<li>// jQuery.extend( target, [ object1 ], [ objectN ] )</li>
<li>// jQuery.extend( [ deep ], target, object1, [ objectN ] )</li>
</ul>


<pre>
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone,
           target = arguments[0] || {},
           i = 1,
           length = arguments.length,
           deep = false;

        // Handle a deep copy situation
        // 如果第一个参数是boolean型，可能是深度拷贝
        if ( typeof target === "boolean" ) {
           deep = target;
           target = arguments[1] || {};
           // skip the boolean and the target
           // 跳过boolean和target，从第3个开始
           i = 2;
        }

        // Handle case when target is a string or something (possible in deep copy)
        // target不是对象也不是函数，则强制设置为空对象
        if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
           target = {};
        }

        // extend jQuery itself if only one argument is passed
        // 如果只传入一个参数，则认为是对jQuery扩展
        if ( length === i ) {
           target = this;
           --i;
        }

        for ( ; i < length; i++ ) {
           // Only deal with non-null/undefined values
           // 只处理非空参数
           if ( (options = arguments[ i ]) != null ) {
               // Extend the base object
               for ( name in options ) {
                  src = target[ name ];
                  copy = options[ name ];

                  // Prevent never-ending loop
                  // 避免循环引用
                  if ( target === copy ) {
                      continue;
                  }

                  // Recurse if we're merging plain objects or arrays
                  // 深度拷贝且值是纯对象或数组，则递归
                  if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                      // 如果copy是数组
                      if ( copyIsArray ) {
                         copyIsArray = false;
                         // clone为src的修正值
                         clone = src && jQuery.isArray(src) ? src : [];
                      // 如果copy的是对象
                      } else {
                         // clone为src的修正值
                         clone = src && jQuery.isPlainObject(src) ? src : {};
                      }

                      // Never move original objects, clone them
                      // 递归调用jQuery.extend
                      target[ name ] = jQuery.extend( deep, clone, copy );

                  // Don't bring in undefined values
                  // 不能拷贝空值
                  } else if ( copy !== undefined ) {
                      target[ name ] = copy;
                  }
               }
           }
        }

        // Return the modified object
        // 返回更改后的对象
        return target;
    };
</pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用栈来找路径]]></title>
    <link href="http://me.94313.net/blog/2012/12/06/use-of-stack/"/>
    <updated>2012-12-06T09:46:51+08:00</updated>
    <id>http://me.94313.net/blog/2012/12/06/use-of-stack</id>
    <content type="html"><![CDATA[<p><img src="http://me.94313.net/images/use-of-stack-01.png" alt="示例图片-01" /></p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt; 数据结构-栈的应用 &lt;/title&gt;
&lt;meta http-equiv="Content-type" content="text/html;charset=utf-8;" &gt;
&lt;style&gt;
*{margin:0;padding:0;}
#container .line{display:block;float:left;}
.block{width:15px;height:15px;float:left;font-size:8px;border-right:1px solid #111;border-bottom:1px solid #111;}
.bld{background:black;color:#fff;}
.start{background:red;color:#fff;}
.end{background:red;color:#f00;}
.route{background:red;}
&lt;/style&gt;
&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.0/jquery.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;使用栈来找路径&lt;/h1&gt;
    &lt;p&gt;
    查找从左上角到右下角的路径，图中的方块表示障碍；点击方块可以改变其状态（通或者不通）
    &lt;/p&gt;
&lt;button text='clear' id="btn-clear"&gt;清除路径&lt;/button&gt;
&lt;button text='clear' id="btn-find"&gt;查找路径&lt;/button&gt;
  &lt;div id='container'&gt;&lt;/div&gt;
  &lt;script type="text/javascript"&gt;
&lt;!--
/***** 入口函数 ****/
$(function(){
    init();
    addEvents();
});

function init(){

    window.M_x = 70;  //矩阵的宽和高
    window.M_y = 45;
    window.Matrix = createMatrix(M_x , M_y);

    showMatrixAsDivBlock(M_x , M_y);
    setDisableBlocks(M_x , M_y , 1100);

    var n1 = [2  , 2];
    var n2 = [M_y-2 ,M_x-2];
    window.startNode = n1;
    window.endNode = n2;

    $(getid(n1)).addClass('start').addClass('route').text('from');
    $(getid(n2)).addClass('end').addClass('route').text('end');
}

/****创建界面****/
function showMatrixAsDivBlock(x , y){
    var div =[]
    var line=[];
    var i , j;
    for(i = 1 ; i &lt; y ; i++){
        for(j = 1 ; j &lt; x ; j++){
            line[j] = "&lt;div id='b-"+i+'-'+j+"' class='block'&gt;&lt;/div&gt;";
        }
        div[i] = '&lt;div class="line"&gt;' + line.join('') + '&lt;/div&gt;';
    }
    $('#container').html(div.join('')+'&lt;div style="clear:both;"&gt;&lt;/div&gt;');
}

/*****创建矩阵****/
function createMatrix(M_x , M_y){
    var Matrix = [];
    for(i = 1; i &lt; M_y; i++){
        Matrix[i] = [];
        for(j = 1; j &lt; M_x; j++){
            if(i==1 || i==M_y-1 || j==1 || j==M_x-1){
                var s = true;
            }else{
                var s = false;
            }
            Matrix[i][j] = {
                disable :s    /// 标示当前的节点是否为阻断 1 ：阻断 ，0 ：联通
                ,x      :i   /// 标示当前节点的x坐标
                ,y      :j   /// 标示当前节点的y坐标
                ,inRoute:false ///标示当前节点是否在路径中
                ,direction:{    /// 标示当前节点四个方向是否被遍历过
                    left:0 , bottom:0 , right:0 , top:0
                }
            };
        }
    }
    return Matrix;
}

/*将所有的障碍设置起来*/
function setDisableBlocks(M_x , M_y , count){

    var i ; var j;
    for(i=1 ; i&lt; M_y ; i++){
        for(j=1 ; j &lt; M_x ; j++){
            if(i==1 || j == 1 || i == M_y-1 || j == M_x-1){
                Matrix[i][j].disable = true;
                $('#b-'+i+'-'+j).addClass('bld');    
            }
        }
    }
    while(count){
        i = parseInt((Math.random() * 10000))% M_y;
        j = parseInt((Math.random() * 10000))% M_x;
        if((i==2 &amp;&amp; j==2) || (i==M_y-2 &amp;&amp; j ==M_x-2)){
            continue;
        }
        if(i &gt; 1 &amp;&amp; i &lt; M_y &amp;&amp; j &gt; 1 &amp;&amp; j &lt; M_x){

            Matrix[i][j].disable = true;
            $('#b-'+i+'-'+j).addClass('bld');
            count--;
        }                
    }
}

/***设置所有“方块”以及两个按钮的单击事件***/
function addEvents(){

    /**清除路径按钮**/
    $('#btn-clear').click(function(){
        for(i = 1 ; i &lt; M_y ; i++){
            for(j = 1 ; j &lt; M_x ; j++){
               var o = window.Matrix[i][j];
               o.inRoute = false;
               o.direction={left:0 , bottom:0 , right:0 , top:0};
            }
        }
        if(window.Stack){
            for(i=0 ; i &lt; Stack.length ; i++){
                var o = Stack[i];
                $(getid([o.x , o.y])).removeClass('route').html('');
            }
        }
    });

    /**查找路径按钮**/
    $('#btn-find').click(function(){
        $('#btn-clear').click();
        find(window.Matrix ,window.startNode , window.endNode);
    });

    /** 方块单击事件**/
    $('.block').click(function(){
        var id = $(this).attr('id');
        var ary = id.split('-');
        var i = ary[1];
        var j = ary[2];
        if(i == 1 || j == 1 || i == M_y || j == M_x){;}else{// 不能改变四个边的状态   
            Matrix[i][j].disable = !Matrix[i][j].disable;
            $('#'+id).toggleClass('bld');
        }
    });
}

// 查找路径
function find(Matrix , n1 , n2){
    // 先标示 起点和终点
    $(getid(n1)).addClass('start').addClass('route').text('from');
    $(getid(n2)).addClass('end').addClass('route').text('end');

    var start = getObject(Matrix , n1);
    var end   = getObject(Matrix , n2)
    var cur = start;

    window.Stack = Stack = [];
    start.inRoute = true;

    while(true){
        if(cur.direction.left == 0 &amp;&amp; (o = getObject(Matrix , [cur.x , cur.y+1])) &amp;&amp; !o.disable ){// &amp;&amp; !o.inRoute){

            cur.direction.left=1;
            o.direction.right=1;
            o.inRoute = true;
            Stack.push(cur);
            Stack.push(o);
            cur = o;

        }else if(cur.direction.bottom == 0 &amp;&amp; (o = getObject(Matrix , [cur.x+1 , cur.y])) &amp;&amp; !o.disable ){// &amp;&amp; !o.inRoute){

            cur.direction.bottom=1;
            o.direction.top=1;
            o.inRoute = true;
            Stack.push(cur);
            Stack.push(o);  
            cur = o;

        }else if(cur.direction.right == 0 &amp;&amp; (o = getObject(Matrix , [cur.x , cur.y-1])) &amp;&amp; !o.disable){// &amp;&amp; !o.inRoute){

            cur.direction.right=1;
            o.direction.left=1;
            o.inRoute = true;
            Stack.push(cur);
            Stack.push(o);  
            cur = o;

        }else if(cur.direction.top == 0 &amp;&amp; (o = getObject(Matrix , [cur.x-1 , cur.y])) &amp;&amp; !o.disable ){// &amp;&amp; !o.inRoute){
            cur.direction.top=1;
            o.direction.bottom=1;
            o.inRoute = true;
            Stack.push(cur);
            Stack.push(o);  
            cur = o;

        }else{
            cur = Stack.pop();
            if(cur){
                cur.inRoute = false;
            }else{
                showMsg('没有路径连接两个点！');
                break;
            }
        }

        if( cur.x == start.x &amp;&amp; cur.y == start.y &amp;&amp; start.direction.left &amp;&amp; start.direction.bottom &amp;&amp; start.direction.right &amp;&amp; start.direction.top){
            showMsg('没有路径连接两个点！');
            break;
        }

        if( cur.x == end.x &amp;&amp; cur.y == end.y){
            break;
        }
    }

    for(i=0 ; i &lt; Stack.length ; i++){
        var tmp = Stack[i];
        $(getid([tmp.x , tmp.y])).addClass('route').html(i/2);
    }
}

// 显示信息
function showMsg(msg){
    alert(msg);
}

function getObject(Matrix , arg){

    if(Matrix[arg[0]] &amp;&amp; Matrix[arg[0]][arg[1]]){
        return Matrix[arg[0]][arg[1]];
    }else{
        return null
    }
}

/**
* 将基于javascript 数组形式的 arg 转换为 jquery id形式
* 用来查找页面中的方块
* 如 : [3,4] =&gt; “#b-3-4” 
**/
function getid(arg){
    return '#b-'+arg[0]+'-'+arg[1];
}
//--&gt;
&lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IT 岗位说明书（岗位职责）]]></title>
    <link href="http://me.94313.net/blog/2012/10/19/it-gangwei-shuoming/"/>
    <updated>2012-10-19T10:17:27+08:00</updated>
    <id>http://me.94313.net/blog/2012/10/19/it-gangwei-shuoming</id>
    <content type="html"><![CDATA[<h2>岗位：程序员</h2>

<p>　　程序员(英文Programmer)是从事程序开发、维护的专业人员。一般我们将程序员分为程序设计人员和程序编码员，但两者的界限并不非常清楚，特别是在中国。
　　作一个真正合格的程序员，应该具有的素质。</p>

<pre><code>1：团队精神和协作能力
　　团队精神和协作能力是作为一个程序员应具备的最基本的素质。软件工程 已经提了将近三十年了，当今的软件开发已经不是编程了，而是工程。独行侠可以写一些程序也能赚钱发财，但是进入研发团队，从事商业化和产品化的开发任务， 就必须具备这种素质。可以毫不夸张的说这种素质是一个程序员乃至一个团队的安身立命之本。
2：文档习惯
　　文档是一个软件系统的生命力。一个公司的产品再好、技术含量再高，如果没有缺乏文档，知识就没有继承，公司还是一个来料加工的软件作坊。作为代码程序员，必须将30％的工作时间写用于技术文档。没有文档的程序员势必会被淘汰。
3：规范化的代码编写习惯
　　知名软件公司的代码的变量命名、注释格式，甚至嵌套中行缩进的长度和函数间的空行数字都有明确规定，良好的编写习惯，不但有助于代码的移植和纠错，也有助于不同技术人员之间的协作。一些所谓的高手甚至叫嚣高手写的代码一般人看不懂，我只能说他不是一名合格的程序员。
4：需求理解能力
　　程序员要能正确理解任务单中描述的需求。在这里要明确一点，程序员不 仅仅要注意到软件的功能需求，还应注意软件的性能需求，要能正确评估自己的模块对整个项目中的影响及潜在的威胁，如果有着两到三年项目经验的熟练程序员对 这一点没有体会的话，只能说明他或许是认真工作过，但是没有用心工作。
5：模块化思维能力
　　作为一个优秀的程序员，他的思想不能在局限当前的工作任务里面，要想 想看自己写的模块是否可以脱离当前系统存在，通过简单的封装在其他系统中或其他模块中直接使用。这样做可以使代码能重复利用，减少重复的劳动，也能是系统 结构越趋合理。模块化思维能力的提高是一个程序员的技术水平提高的一项重要指标。
6：测试习惯
　　测试是软件工程质量保证的重要环节，但是测试不仅仅是测试工程师的工作，而是每个程序员的一种基本职责。程序员要认识测试不仅是正常的程序调试，而要是要进行有目的有针对性的异常调用测试，这一点要结合需求理解能力。
7：学习和总结的能力
　　程序员是很容易被淘汰的职业，所以要善于学习总结。许多程序员喜欢盲 目追求一些编码的小技巧，这样的技术人员无论学了多少语言，代码写起来多熟练，我们只能说他是一名熟练的代码民工，他永远都不会有质的提高。一个善于学习 的程序员会经常总结自己的技术水平，对自己的技术层面要有良好的定位，这样才能有目的地提高自己。这样才能逐步提高，从程序员升级为软件设计师、系统分析 员。
</code></pre>

<p>　　</p>

<pre><code>作为高级程序员，乃至于设计师而言，除了应该具备上述全部素质之外，还需要具备以下素质：
    1、 需求分析能力
    2、 整体框架能力
    3、 流程处理能力
    4、 模块分解能力
    5、 整体项目评估能力
    6、 团队组织管理能力
</code></pre>

<p>　</p>

<h3>岗位：项目经理</h3>

<p>主要职责：</p>

<pre><code>1、 计划：
    a)项目范围、项目质量、项目时间、项目成本的确认。
    b)项目过程/活动的标准化、规范化。
    c)根据项目范围、质量、时间与成本的综合因素的考虑，进行项目的总体规划与阶段计划。
    d)各项计划得到上级领导、客户方及项目组成员认可。
2、 组织：
    a)组织项目所需的各项资源。
    b)设置项目组中的各种角色，并分配好各角色的责任与权限。
    c)定制项目组内外的沟通计划。（必要时可按配置管理要求写项目策划目录中的《项目沟通计划》）
    d)安排组内需求分析师、客户联系人等角色与客户的沟通与交流。
    e)处理项目组与其它项目干系人之间的关系。
    f)处理项目组内各角色之间的关系、处理项目组内各成员之间的关系。
    g)安排客户培训工作。
3、 领导：
    a)保证项目组目标明确且理解一致。
    b)创建项目组的开发环境及氛围，在项目范围内保证项目组成员不受项目其它方面的影响。
    c)提升项目组士气，加强项目组凝聚力。
    d)合理安排项目组各成员的工作，使各成员工作都能达到一定的饱满度。
    e)制定项目组需要的招聘或培训人员的计划。
    f)定期组织项目组成员进行相关技术培训以及与项目相关的行业培训等。
    g)及时发现项目组中出现的问题。
    h)及时处理项目组中出现的问题。
4、 控制
    a)保证项目在预算成本范围内按规定的质量和进度达到项目目标。
    b)在项目生命周期的各个阶段，跟踪、检查项目组成员的工作质量；
    c)定期向领导汇报项目工作进度以及项目开发过程中的难题。
    d)对项目进行配置管理与规划。
    e)控制项目组各成员的工作进度，即时了解项目组成员的工作情况，并能快速的解决项目组成员所碰到的难题。
    f)不定期组织项目组成员进行项目以外的短期活动，以培养团队精神。
</code></pre>

<p>结语：
项目经理是在整个项目开发过程中项目组内对所有非技术性重要事情做出最终决定的人。</p>

<h3>岗位：系统架构师（技术总监）</h3>

<p>主要功能及职责：</p>

<pre><code>1、系统架构师是软件项目的总体设计师，是软件组织新产品的开发与集成、新技术体系的构建者。
2、系统架构师是在技术上对所有重要事情做出决定的人。（系统架构师在整个软件开发过程中都起着重要作用，并随着开发进程的推进而其职责或关注点不断地变化。）
3、 需求阶段，软件架构师负责理解和管理非功能性系统需求，比如软件的可维护性、性能、复用性、可靠性、有效性和可测试性等。审查客户和市场人员所提出的需 求，确认开发团队所提出的设计；组织开发团队成员和开发过程的定义；协助需求分析师完成《用户需求说明书》、《需求变更说明书》。
4、设计阶段，架构师负责对整个软件架构、关键构件、接口的设计。协助系统分析师完成《系统概要设计说明书》
5、编码阶段，架构师则成为程序员的顾问，并且经常性地要举行一些技术研讨会、技术培训班等；
6、测试及实施阶段，随着软件开始测试、集成和交付，集成和测试支持将成为软件架构师的工作重点；
</code></pre>

<p>结语：
系统架构师也可以理解成技术总监。系统架构师是在部门内所有软件项目中，对技术上所有重要的事情做出决定的人。</p>

<h3>岗位：需求分析师</h3>

<p>主要职责：</p>

<pre><code>1、在项目前期根据《需求调研计划》对客户进行需求调研。
2、收集整理客户需求，负责编写《用户需求说明书》。
3、代表项目组与用户沟通与项目需求有关的所有事项。
4、代表客户与项目组成员沟通项目需求有关的所有事项。
5、负责《用户需求说明书》得到用户的认可与签字。
6、负责将完成的项目模块给客户做演示，并收集对完成模块的意见。
7、完成《需求变更说明书》，并得到用户的认可与签字。
8、并协助系统架构师、系统分析师对需求进行理解。
</code></pre>

<p>结语：
需求分析师是项目前期与客户方打交道最多的人，对于客户来说，他可以代表整个项目组，对与项目组成员来说他的意见可以代表客户方的意见，项目组内所有与客户需求相关的事情必需得到他的认可。</p>

<h3>岗位：系统分析师</h3>

<p>主要职责：</p>

<pre><code>1、 协助需求分析师进行需求调研。
2、分析、解析《用户需求说明书》，将系统需求整理成《软件需求规格说明书》；
3、负责解决《软件需求规格说明书》被评审后发现的问题；
4、在分析系统前，负责向架构设计师解释《软件需求规格说明书》的内容。
5、协助架构设计师进行架构设计，并协助其完成《系统架构说明书》。
6、根据《系统架构说明书》对系统进行建模；
7、系统分析及建模完成后，负责将建模成果转化为《系统概要设计》；
8、协助数据库设计师按《系统概要设计说明书》进行数据库逻辑设计和物理设计，完成数据库CDM及PDM图，并协助其完成《数据库设计说明书》
9、协助软件设计师按《系统概要设计说明书》进行《系统详细设计说明书》。
10、指导软件工程师按《系统详细设计说明书》进行代码实现。
11、 负责重点代码检查；
12、协助项目经理进行配置管理，并提供优化改进建议；
13、定期对项目组成员进行技术方面的培训。
</code></pre>

<p>结语：
系统分析师是项目组中的首席执行官，他涉及项目的所有方面，是项目进度的推动者，也是项目成功的关键。</p>

<h3>岗位：数据库设计师</h3>

<p>主要职责：</p>

<pre><code>1、根据《系统架构说明书》与系统架构师、系统分析师一同进行数据库建模。
2、根据数据库建模结果，绘制数据库CDM与PDM图。
3、 根据数据库PDM图进行数据库建库。
4、 对数据库进行维护、备份、恢复、同步。
5、 负责客户数据的导入导出。
6、 对数据库进行初始化操作。
7、协助软件设计师完成《系统详细设计说明书》中与数据库相关的部分。
8、根据《系统详细设计说明书》编写对应的视图、存储过程、函数、触发器等。
9、对项目组其它成员进行SQL方面的指导。
10、定期对项目组其它成员进行数据库方面知识的培训。
11、为测试经理及测试工程师建立测试数据。
</code></pre>

<p>结语：
数据库设计师又称DBA，是项目组中唯一能对数据库进行直接的操作的人。对项目中与数据库相关的所有重要的事做最终决定的人。</p>

<h3>岗位：软件设计师（模块）</h3>

<pre><code>1、根据《系统概要设计说明书》编写分模块的《系统详细说明书》。
2、负责对软件工程师讲解《系统详细设计说明书》内容。
3、协助软件工程师按《系统详细设计说明书》进行代码实现。
4、 控制本模块的开发进度。
</code></pre>

<p>结语：
软件设计师又称模块设计师，协助系统分析师对分模块进行详细设计，并直接管控该模块的进度，对于本模块中所有重要的事做最终决定的人。</p>

<h3>岗位：软件工程师</h3>

<p>主要职责：</p>

<pre><code>1.根据《系统详细设计说明书》进行代码实现；
2.对自己代码进行复查，并进行简单的测试；
</code></pre>

<p>结语：
软件工程师是最终实现代码的成员。</p>

<h3>岗位：测试经理</h3>

<p>主要职责：</p>

<pre><code>1.独立编写测试计划；
2.独立编写测试用例；
3.协调测试团队内部的工作以及与开发团队之间的工作；
4.完成“执行测试”的工作；
5.掌握较深层次的测试方法、测试技术和较复杂的业务流程；
6.负责测试过程工具的研究、推广与维护，负责测试数据库维护工作；
7.负责编写《用户手册》、《操作手册》和相关培训教材；
8.负责项目的质量审查。
</code></pre>

<p>结语：
测试经理其实应该是整个项目中最关心项目质量的人，他的主要工作就是找到项目中存在的不合理、不合格的部份，并要求项目其它成员按其给定的项目质量完成项目。</p>

<h3>岗位：测试工程师</h3>

<p>主要职责：</p>

<pre><code>1.在测试经理的安排和指导下，编写测试用例；
2.在测试经理的安排和指导下，完成“执行测试”的工作；
3.在测试经理的指导下，按测试计划进行测试工作；
4.按测试用例进行测试工作。
5.负责被分派项目的质量审计。
6.了解项目的基本流程，可以熟练的进行项目中各种流程的操作。
</code></pre>

<p>结语：
测试工程师是项目质量的保证，是最终进行项目测试的成员。</p>

<h3>岗位：实施经理</h3>

<p>主要职责：</p>

<pre><code>1.负责制定项目实施计划；
2.在项目实施计划的约束下，协调项目组相关资源，完成系统实施相关工作（包括系统安装、用户培训、系统上线、系统试运行等）；
3.在项目实施阶段，跟踪、检查实施人员的工作质量；
5.负责协助用户进行“用户确认测试”和编写《确认测试报告》。
</code></pre>

<h3>岗位：实施工程师</h3>

<p>主要职责：</p>

<pre><code>1.在实施经理安排和指导下，执行项目用户现场实施任务；
2.参与编写《用户手册》、《操作手册》和相关培训教材；
3.参与进行“用户确认测试”和编写《确认测试报告》。
</code></pre>

<h3>岗位：美术工程师</h3>

<p>主要职责：</p>

<pre><code>1.负责完成软件设计师安排的功能界面设计。
2.负责对项目整体色彩的调配。
3.向系统分析师提出项目美化的建议。
4.为BS项目提供一套或几套CSS样式表及HTML结构表
5.为CS项目提供符合项目内容的静态、动态图片。
6.并为软件设计师提供界面指导。
</code></pre>

<h3>岗位：客户经理（当所开发的项目属于定制型的项目时设立，可由项目经理或部门经理兼）</h3>

<p>主要职责：</p>

<pre><code>1.策划并独立完成目标客户的拜访和沟通；
2.定期分析、整理客户需求，制定有针对性的方案；
3.进行重点客户的关系维护，了解并整理重点客户的需求，为开发更符合用户需求的产品提供富有价值的市场信息；
4.参与产品定位的研讨，为产品策划献计献策。
</code></pre>

<h3>岗位：产品经理（当所开发的项目为产品型项目时设立，可由市场部成员兼）</h3>

<p>主要职责：</p>

<pre><code>1.对所负责的产品进行策划和管理；
2.对所负责的产品进行市场调研和分析，及时提出应对措施；
3.负责产品实现的内部管理，保证产品功能的顺利实现以及时满足市场需求；
4.负责产品对外宣传与推广，开拓市场，提高产品品牌知名度和认可度；
5.配合销售制订产品销售策略，支持市场销售业务。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSA加密算法简单介绍]]></title>
    <link href="http://me.94313.net/blog/2012/05/30/intr-rsa/"/>
    <updated>2012-05-30T20:40:02+08:00</updated>
    <id>http://me.94313.net/blog/2012/05/30/intr-rsa</id>
    <content type="html"><![CDATA[<p>这种算法1978年就出现了，它是第一个既能用于数据加密也能用于数字签名的算法。它易于理解和操作，也很流行。
   算法的名字以发明者的名字命名：Ron Rivest, AdiShamir 和Leonard Adleman。
   　　RSA算法是一种非对称密码算法，所谓非对称，就是指该算法需要一对密钥，使用其中一个加密，则需要用另一个
   才能解密。
   　　RSA的算法涉及三个参数，n、e、d。
   　　其中，n是两个大质数p、q的积。n的二进制表示时所占用的位数，就是所谓的密钥长度。
   　　e和d是一对相关的值，e可以任意取，但要求满足e&lt;(p-1)<em>(q-1)并具 e与(p-1)</em>(q-1)互质（就是最大公约数为1）；
   再选择d，要求(d<em>e)mod((p-1)</em>(q-1))=1。
   　　(n及e),(n及d)就是密钥对。
   　　RSA加解密的算法完全相同,设M为明文，c为密文，则：</p>

<pre><code>   加密：C=M^e mod n; 
   解密：m=c^d mod n;
</code></pre>

<p>   　　注：上面两式中的e和d可以互换。</p>

<pre><code>   n d两个数构成公钥，可以告诉别人；
   n e两个数构成私钥，e自己保留，不让任何人知道。
   给别人发送的信息使用私钥e加密,只要别人能用公钥d解开就证明信息是由你发送的,构成了签名机制,起验证身份的作用。
</code></pre>

<p>   别人给你发送信息时使用d加密，这样只有拥有e的你能够对其解密,起到数据保密的作用。<br/>
   整理一下：</p>

<pre><code>为实现RSA的加解密
最终目标：找三个参数 n,e,d
1、n = p*q (p,q 是两个质数)
2、 
    1)、φ(N)=(p-1)*(q-1)
    2)、取任何一个数e,要求满足e&lt;φ(N)并且e与φ(N)互质
3、(d*e) modφ(N)=1
</code></pre>

<p>//================================================================
加密的明文长度不能超过RSA密钥的长度-11，比如1024位的，明文长度不能超过117。 <br/>
密文的长度总是密钥的长度的一半，比如1024位的，密文长度是64，如果是1032位，密文长度是65位。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux命令行技巧]]></title>
    <link href="http://me.94313.net/blog/2012/03/23/command-line-skill-of-linux/"/>
    <updated>2012-03-23T13:18:37+08:00</updated>
    <id>http://me.94313.net/blog/2012/03/23/command-line-skill-of-linux</id>
    <content type="html"><![CDATA[<h2>编辑命令</h2>

<pre><code>* Ctrl + a ：移到命令行首
* Ctrl + e ：移到命令行尾
* Ctrl + f ：按字符前移（右向）
* Ctrl + b ：按字符后移（左向）
* Alt + f ：按单词前移（右向）
* Alt + b ：按单词后移（左向）
* Ctrl + xx：在命令行首和光标之间移动
* Ctrl + u ：从光标处删除至命令行首
* Ctrl + k ：从光标处删除至命令行尾
* Ctrl + w ：从光标处删除至字首
* Alt + d ：从光标处删除至字尾
* Ctrl + d ：删除光标处的字符
* Ctrl + h ：删除光标前的字符
* Ctrl + y ：粘贴至光标后
* Alt + c ：从光标处更改为首字母大写的单词
* Alt + u ：从光标处更改为全部大写的单词
* Alt + l ：从光标处更改为全部小写的单词
* Ctrl + t ：交换光标处和之前的字符
* Alt + t ：交换光标处和之前的单词
* Alt + Backspace：与 Ctrl + w 相同类似
</code></pre>

<h2>重新执行命令</h2>

<pre><code>* Ctrl + r：逆向搜索命令历史
* Ctrl + g：从历史搜索模式退出
* Ctrl + p：历史中的上一条命令
* Ctrl + n：历史中的下一条命令
* Alt + .：使用上一条命令的最后一个参数
</code></pre>

<h2>控制命令</h2>

<pre><code>* Ctrl + l：清屏
* Ctrl + o：执行当前命令，并选择上一条命令
* Ctrl + s：阻止屏幕输出
* Ctrl + q：允许屏幕输出
* Ctrl + c：终止命令
* Ctrl + z：挂起命令
</code></pre>

<h2>Bang (!) 命令</h2>

<pre><code>* !!：执行上一条命令
* !blah：执行最近的以 blah 开头的命令，如 !ls
* !blah:p：仅打印输出，而不执行
* !$：上一条命令的最后一个参数，与 Alt + . 相同
* !$:p：打印输出 !$ 的内容
* !*：上一条命令的所有参数
* !*:p：打印输出 !* 的内容
* ^blah：删除上一条命令中的 blah
* ^blah^foo：将上一条命令中的 blah 替换为 foo
* ^blah^foo^：将上一条命令中所有的 blah 都替换为 foo
</code></pre>

<h2>注意：</h2>

<pre><code>1. 以上介绍的大多数 Bash 快捷键仅当在 emacs 编辑模式时有效，若你将 Bash 配置为 vi 编辑模式，那将遵循 vi 的按键绑定。Bash 默认为 emacs 编辑模式。如果你的 Bash 不在 emacs 编辑模式，可通过 set -o emacs 设置。
2. ^S、^Q、^C、^Z 是由终端设备处理的，可用 stty 命令设置。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Yum配置笔记]]></title>
    <link href="http://me.94313.net/blog/2012/03/02/note-of-yum/"/>
    <updated>2012-03-02T10:11:18+08:00</updated>
    <id>http://me.94313.net/blog/2012/03/02/note-of-yum</id>
    <content type="html"><![CDATA[<h3>YUM 优点</h3>

<p>自动解决包的依赖性的问题能更新的添加/删除/更新/RPM包
便于管理大量系统的更新问题
可以同时配置多个资源库（Repository）
简洁的配置文件(/etc/yum.conf)
保持与RPM数据库的一致性
有一个比较详细的log.可以查看何时升级了什么软件包</p>

<h3>CentOS的镜像站点</h3>

<p>了解 镜像站点的文件结构 对理解 yum 配置文件 .repo 文件有帮助</p>

<pre><code>http://mirror-status.centos.org
http://isoredirect.centos.org/centos/5/isos/i386/
addons/      本目录包含Centos的addons 仓库
centosplus/  本目录包含Centos的centosplus 仓库
extras/      本目录包含Centos的extras 仓库
fasttrack/   本目录包含Centos的extras 仓库
isos-dvd/    本目录包含发行版的DVD iso 下载
isos/        本目录包含发行版 CD iso 下载
os/          本目录包含发行版(distributions)的仓库
updates/     本目录包含Centos的updates仓库
</code></pre>

<h3>CentOS 的仓库</h3>

<p>仓库(repository) 是一个预备好的目录or 网站，包含了软件包和索引。
yum 可以在仓库中自动定位并获取正确的RPM软件。
镜像服务器为每个版本的Centos分别提供了一些仓库。
Centos中的软件管理工具 yum已经预先配置为使用下列四个仓库：
base: 构成Centos发行版(distributions)的软件包，和光盘上的内容相同
updates: base 仓库中软件包的更新版本
addons: 已编译的但不在发行版(distributions)中的软件包
extras: 一大批附加的软件包
centospuls:　用于增强一些现有软件包的功能(默认未启用)</p>

<h3>CentOS 仓库的目录结构</h3>

<pre><code>updates/
 |--SRPMS                        #源代码目录
 |  |--*.src.rpm                #源代码包目录    
 |    |--repodata/                #源代码的索引文件
 |--i386                        #Intel 32位平台的目录
 |    |--RPMS                        #Intel 32位平台的RPMS目录
 |    |    |--*.i386.rpm            #在intel 32位平台上编译的包文件
 |    |    |--*.centos.noarch.rpm    #与平台无关的已编译的包文件
 |    |--repodata/                #intel 32位平台的索引文件
 |--x68_64                        #64位平台的目录
    |--RPMS                        #64位平台的RPMS目录
    |    |--x68_64.rpm            #在64位平台上编译的包文件
    |    |--*.centos.noarch.rpm    #与平台无关的已编译的包文件
    |--repodata/                #64位平台的索引文件
</code></pre>

<h3>配置YUM客户的更新源</h3>

<p>yum使用reposdir /etc/yum.repos.d 目录下的一系列.repo 文件列出可获取软件包仓库的镜像站点地址.
默认情况下有两个：
Centos-Base.repo: 用于设置远程仓库
Centos-Media.repo: 用于设置本地仓库</p>

<p>yum 目录结构</p>

<pre><code>/etc
  |--yum/
  |   |--/pluginconf.d    
  |   |--/yum-updatesd.conf/
  |            |--downloadonly.conf
  |            |--fastestmirror.conf
  |            |--priorities.conf
  |--yum.conf
  |--yum.repos.d/
        |--CentOS-Base.repo
        |--CentOS-Media.repo
</code></pre>

<p>在.repo 文件中，配置语法是分段的，每一段配置一个软件仓库，语法如下：
设置网络更新源
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p>

<pre><code>[base]  \\用于指定仓库
name=CentOS-$releasever - Base \\用于指定易读的仓库名称
mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os \\用于指定本仓库的URL
#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
#        =ftp://  \\用于指定远程ftp协议的愿
#        =file://  \\ 用于本地镜像或NFS挂载文件系统
#nabled=0/1  \\用于指定是否使用本地仓库，默认为1，即可用。
gpgcheck=1  \\用于指定是否检查软件包的GPG签名
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5  \\用于指定GPG签名文件的URL
</code></pre>

<p>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
注：若指定mirrorlist,系统将从Centos 的镜像站点中选择离你最近的仓库。
[$releasever]当前系统的版本号
[$basearch] 当前系统的构架
baseurl 可以指定多个URL ,系统会依次检查你列出的仓库。以便某个服务器宕机时使用另一台服务器</p>

<h3>设置本地更新源</h3>

<p>为了使用 [c5-media]仓库，需将Centos-Base</p>

<pre><code>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[c5-media]
name=CentOS-$releasever - Media
baseurl=file:///media/CentOS/
        file:///media/cdrom/
        file:///media/cdrecorder/
gpgcheck=1
enabled=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5
</code></pre>

<p>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p>

<h3>设置非官方更新源</h3>

<pre><code>以安置rpmforge 软件包为例在
http://rpm.pbone.net/
http://dag.wieers.com/rpm/
http://rpmforge.net
http://rpm.livna.org
http://freshrpms.net
http://atrpms.net
中找到适用于 Centos 5 的软件包
wget http://................rpmforge-release..... .rpm
rpm -ivh rpmforge-release........... .rpm
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-rpmforge-*
</code></pre>

<p>安装 rpmforge-release 软件包之后可以看到/etc/yum.repos.d/rpmfoge.repo文件</p>

<p>or建立一个DAG 的仓库
vi /etc/yum.repos.d/dag.repo</p>

<pre><code>[dag]
name=Dag RPM Repository for Red Hat Enterprise Linux
baseurl=http://apt.sw.be/redhat/el$releasever/en/$basearch/dag
gpgcheck=1
enabled=1
gpgkey=http://dag.wieers.com/packages/RPM-GPG-KYE.dag.txt
</code></pre>

<h3>yum 命令工具</h3>

<pre><code>yum check-update            检查可更新的软件包
yum update                    下载更新系统已安装的所有软件把
yum upgrade                    大规模的升级，不同于上面的是,连旧的淘汰的包也升级
yum install &lt;packages&gt;        安装指定的软件包
yum update &lt;packages&gt;        更新指定的软件包
yum remove &lt;packages&gt;        卸载指定的软件包
yum groupinstall &lt;packages&gt;    安装指定的软件组中的软件包
yum groupupdate &lt;packages&gt;    更新 ... ...
yum groupremove &lt;packages&gt;    卸载 ... ...
yum grouplist                查看系统中已经安装的和可以用的软件组
yum list                    列出资源库中所有可以安装or 更新以及已经安装的的rpm包
yum list &lt;regex&gt;             列出资源库中与正则表达式匹配的可以安装或更新以及已经安装的rpm包
yum list available             列出资源库中所有可以安装的rpm包
yum list available &lt;regex&gt;     列出资源库中与正则表达式匹配的所有可以安装的rpm包
yum list updates             列出资源库中所有可以更新的rpm包
yum list updates &lt;regex&gt;     列出资源库中与正则表达式匹配的所有可以更新的rpm包
yum list installed             列出资源库中所有已经安装的rpm包
yum list installed &lt;regex&gt;     列出资源库中与正则表达式匹配的所有已经安装的rpm包
yum list extras             列出已经安装的但是不包含在资源库中的rpm包
yum list extras &lt;regex&gt;     列出与正则表达式匹配的已经安装的但是不包含在资源库中的rpm包
yum list recent             列出最近被添加到资源库中的软件包
yum search &lt;regex&gt;             检测所有可用的软件的名称、描述、概述和已列出的维护者，查找与正则表达式匹配的值
yum provides &lt;regex&gt;         检测软件包中包含的文件以及软件提供的功能，查找与正则表达式匹配的值
yum clean headers             清除缓存中的rpm头文件
yum clean packages             清除缓存中rpm包文件
yum clean all                 清除缓存中的rpm头文件和包文件
yum deplist &lt;packages&gt;         显示软件包的依赖信息
</code></pre>

<p>第一次使用yum或者yum资源库有更新是.yum会自动下载所有需要的headers 放置于/var/cache/yum
还可以用yum info 命令列出包信息,yum info 可用的参数与 yum list的相同
yum 命令还可以使用 -y 参数 回答命令运行时所提出的问题。</p>

<p>yum update 升级时 排除升级内核
yum update 排除升级内核，方法有两个:
1.修改yum的配置文件 vi /etc/yum.conf，在[main]的最后添加exclude=kernel<em>
2.直接在yum的命令行执行如下的命令：
yum –exclude=kernel</em> update</p>

<h3>附：</h3>

<p>当仓库配置文件 *.repo 使用了多个URL yum-fastestmirror  可以自动选择最快的镜像站点</p>

<pre><code>yum -y install yum-fastestmirror
yum-fastestmirror 的配置文件在 /etc/yum/pluginconf.d/fastestmirror.conf 默认不需要修改。

yum -updatesd
rpm -ql yum-updatesd
yum -cron
yum -y install yum-cron
rpm -ql yum-cron
/etc
    |--/cron.daily/yum.cron        每日更新脚本
    |--/cron.weekly/yum.cron    每周更新脚本
    |--/rc.d/int.d/yum            启动脚本
    |--/yum/yum-daily.yum
/usr/share/doc/yum-cron-0.1
                        |--/COPYING
                        |--/README
</code></pre>

<p>使用yum下载而不安装rpm包
先安装yum-downloadonly</p>

<pre><code># yum install yum-downloadonly
</code></pre>

<p>安装后使用方法如下:</p>

<pre><code># yum update httpd -y --downloadonly   ###下载到默认目录  /var/cache/yum
OR
# yum update httpd -y --downloadonly --downloaddir=/opt     ##下载到指定目录
# yum install perl-MailTools --downloadonly --downloaddir=/opt -y     ##如果软件已经下载过了，必须使用这个来下载
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Mysql字符集设置]]></title>
    <link href="http://me.94313.net/blog/2012/01/17/understand-mysql-charset/"/>
    <updated>2012-01-17T10:39:27+08:00</updated>
    <id>http://me.94313.net/blog/2012/01/17/understand-mysql-charset</id>
    <content type="html"><![CDATA[<h3>基本概念</h3>

<ul>
<li>字符(Character)是指人类语言中最小的表义符号。例如’A’、’B’等；</li>
<li>给定一系列字符，对每个字符赋予一个数值，用数值来代表对应的字符，这一数值就是字符的编码(Encoding)例如，我们给字符’A’赋予数值0，给字符’B’赋予数值1，则0就是字符’A’的编码；</li>
<li>给定一系列字符并赋予对应的编码后，所有这些字符和编码对组成的集合就是字符集(Character Set)。例如，给定字符列表为{’A’,’B’}时，{’A’=>0, ‘B’=>1}就是一个字符集；</li>
<li>字符序(Collation)是指在同一字符集内字符之间的比较规则；</li>
<li>确定字符序后，才能在一个字符集上定义什么是等价的字符，以及字符之间的大小关系；</li>
<li>每个字符序唯一对应一种字符集，但一个字符集可以对应多种字符序，其中有一个是默认字符序(Default Collation)；</li>
<li>MySQL中的字符序名称遵从命名惯例：以字符序对应的字符集名称开头；以<em>ci(表示大小写不敏感)、</em>cs(表示大小写敏感)或_bin(表示按编码值比较)结尾。例如：在字符序“utf8_general_ci”下，字符“a”和“A”是等价的；</li>
</ul>


<h3>MySQL字符集设置</h3>

<p>• 系统变量：</p>

<pre><code>– character_set_server：默认的内部操作字符集
– character_set_client：客户端来源数据使用的字符集
– character_set_connection：连接层字符集
– character_set_results：查询结果字符集
– character_set_database：当前选中数据库的默认字符集
– character_set_system：系统元数据(字段名等)字符集
– 还有以collation_开头的同上面对应的变量，用来描述字符序。
</code></pre>

<p>• 用introducer指定文本字符串的字符集：</p>

<pre><code>– 格式为：[_charset] ’string’ [COLLATE collation]
– 例如：
    • SELECT _latin1 ’string’;
    • SELECT _utf8 ‘你好’ COLLATE utf8_general_ci;
– 由introducer修饰的文本字符串在请求过程中不经过多余的转码，直接转换为内部字符集处理。
</code></pre>

<h3>MySQL中的字符集转换过程</h3>

<pre><code>1. MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；
2. 进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：
    • 使用每个数据字段的CHARACTER SET设定值；
    • 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；
    • 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；
    • 若上述值不存在，则使用character_set_server设定值。
3. 将操作结果从内部操作字符集转换为character_set_results。
</code></pre>

<p><img src="http://me.94313.net/images/understand-mysql-charset-01.jpg" alt="understand-mysql-charset" /></p>

<h3>常见问题解析</h3>

<ul>
<li>向默认字符集为utf8的数据表插入utf8编码的数据前没有设置连接字符集，查询时设置连接字符集为utf8</li>
<li>插入时根据MySQL服务器的默认设置，character_set_client、character_set_connection和character_set_results均为latin1；</li>
<li>插入操作的数据将经过latin1=>latin1=>utf8的字符集转换过程，这一过程中每个插入的汉字都会从原始的3个字节变成6个字节保存；</li>
<li>查询时的结果将经过utf8=>utf8的字符集转换过程，将保存的6个字节原封不动返回，产生乱码……</li>
</ul>


<p><img src="http://me.94313.net/images/understand-mysql-charset-02.jpg" alt="understand-mysql-charset" /></p>

<ul>
<li>向默认字符集为latin1的数据表插入utf8编码的数据前设置了连接字符集为utf8</li>
<li>插入时根据连接字符集设置，character_set_client、character_set_connection和character_set_results均为utf8；</li>
<li>插入数据将经过utf8=>utf8=>latin1的字符集转换，若原始数据中含有\u0000~\u00ff范围以外的Unicode字 符，会因为无法在latin1字符集中表示而被转换为“?”(0×3F)符号，以后查询时不管连接字符集设置如何都无法恢复其内容了。</li>
</ul>


<p><img src="http://me.94313.net/images/understand-mysql-charset-02.jpg" alt="understand-mysql-charset" /></p>

<h3>检测字符集问题的一些手段</h3>

<ul>
<li>SHOW CHARACTER SET;</li>
<li>SHOW COLLATION;</li>
<li>SHOW VARIABLES LIKE ‘character%’;</li>
<li>SHOW VARIABLES LIKE ‘collation%’;</li>
<li>SQL函数HEX、LENGTH、CHAR_LENGTH</li>
<li>SQL函数CHARSET、COLLATION</li>
</ul>


<h3>使用MySQL字符集时的建议</h3>

<ul>
<li>建立数据库/表和进行数据库操作时尽量显式指出使用的字符集，而不是依赖于MySQL的默认设置，否则MySQL升级时可能带来很大困扰；</li>
<li>数据库和连接字符集都使用latin1时虽然大部分情况下都可以解决乱码问题，但缺点是无法以字符为单位来进行SQL操作，一般情况下将数据库和连接字符集都置为utf8是较好的选择；</li>
<li>使用mysql C API时，初始化数据库句柄后马上用mysql_options设定MYSQL_SET_CHARSET_NAME属性为utf8，这样就不用显式地用 SET NAMES语句指定连接字符集，且用mysql_ping重连断开的长连接时也会把连接字符集重置为utf8；</li>
<li>对于mysql PHP API，一般页面级的PHP程序总运行时间较短，在连接到数据库以后显式用SET NAMES语句设置一次连接字符集即可；但当使用长连接时，请注意保持连接通畅并在断开重连后用SET NAMES语句显式重置连接字符集。</li>
</ul>


<h3>其他注意事项</h3>

<ul>
<li>my.cnf中的default_character_set设置只影响mysql命令连接服务器时的连接字符集，不会对使用libmysqlclient库的应用程序产生任何作用！</li>
<li>对字段进行的SQL函数操作通常都是以内部操作字符集进行的，不受连接字符集设置的影响。</li>
<li>SQL语句中的裸字符串会受到连接字符集或introducer设置的影响，对于比较之类的操作可能产生完全不同的结果，需要小心！</li>
</ul>

]]></content>
  </entry>
  
</feed>
